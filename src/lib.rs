//! The main goal behind `jlrs` is to provide a simple and safe interface to the Julia C API.
//! Currently this crate has only been tested on Linux, if you try to use it on another OS it will
//! likely fail to generate the bindings to Julia.
//!
//! # Generating the bindings
//! This crate depends on [`jl-sys`] which contains the raw bindings to the Julia C API, these are
//! generated by `bindgen`. The recommended way to install Julia is to download the binaries from
//! the official website, which is distributed in an archive containing a directory called
//! `julia-x.y.z`. This directory contains several other directories, including a `bin` directory
//! containing the `julia` executable.
//!
//! In order to ensure the `julia.h` header file can be found, you have to set the `JL_PATH`
//! environment variable to `/path/to/julia-x.y.z`. Similarly, in order to load `libjulia.so` you
//! must add `/path/to/julia-x.y.z/lib` to the `LD_LIBRARY_PATH` environment variable. If they can
//! be found at the standard locations, e.g. because you've installed Julia through your package
//! manager, this is not necessary and things should build without setting the `JL_PATH`
//! environment variable.
//!
//! # Using this crate
//! The first thing you should do is `use` the [`prelude`]-module with an asterisk, this will
//! bring all the structs and traits you're likely to need in scope. Before you can use Julia it
//! must first be initialized. You do this by creating a [`Runtime`] with [`Runtime::new`], this
//! method forces you to pick a `stack size`. You will learn how to choose this value soon. Note
//! that this method can only be called once, if you drop the [`Runtime`] you won't be able to
//! create a new one and have to restart the entire program.
//!
//! With the [`Runtime`] you can do two things: you can call [`Runtime::include`] to include your
//! own Julia code and either [`Runtime::frame`] or [`Runtime::dynamic_frame`] to interact with
//! Julia. If you want to create arrays with more than three dimensions or borrow arrays with more
//! than one, you should include `jlrs.jl` first. You can find this file in the root of this
//! crate's github repository. This is necessary because this functionality currently depends on
//! some Julia code defined in that file.
//!
//! The other two methods, [`Runtime::frame`] and [`Runtime::dynamic_frame`], take a closure that
//! provides you with a [`StaticFrame`] and a [`DynamicFrame`] respectively. Both types implement
//! the [`Frame`] trait. These frames are used to create new values, access Julia modules and
//! their functions, call functions, and copy data back to Rust. Additionally, frames can be
//! nested; you're free to mix static and dynamic frames. The main reason things work this way is
//! that it ensures that all active values are protected from being freed by Julia's garbage
//! collector.
//!
//! In order to call a Julia function, you'll need two things: a function to call, and arguments
//! to call it with. You can acquire the function through the module that defines it with
//! [`Module::function`]; [`Module::base`] and [`Module::core`] provide access to Julia's `Base`
//! and `Core` module respectively, while everything you include through [`Runtime::include`] is
//! made available relative to the `Main` module which you can access by calling [`Module::main`].
//!
//! Most Julia data is represented by a [`Value`]. Basic data types like numbers, booleans, and
//! strings can be created through [`Value::new`] and several methods exist to create an
//! n-dimensional array. Julia functions, their arguments and their results are all `Value`s. All
//! `Value`s can be called as functions, whether this will succeed depends on the value actually
//! being a function. You can copy data from Julia to Rust by calling [`Value::try_unbox`].
//!
//! As a simple example, let's create two values and add them:
//!
//! ```no_run
//! # use jlrs::prelude::*;
//! # fn main() {
//! // Create the runtime and interact with Julia from a dynamic frame
//! let mut runtime = unsafe { Runtime::new(16).unwrap() };
//! runtime.dynamic_frame(|frame| {
//!     // Create the two arguments
//!     let i = Value::new(frame, 2u64)?;
//!     let j = Value::new(frame, 1u32)?;
//!
//!     // We can find the addition-function in the base module
//!     let func = Module::base(frame).function("+")?;
//!
//!     // Call the function and unbox the result
//!     let output = func.call2(frame, i, j)?;
//!     output.try_unbox::<u64>()
//! }).unwrap();
//! # }
//! ```
//!
//! # Memory management
//! Julia is a garbage collected language. In order to prevent data from being freed while it is
//! still in use, a stack is managed in the background that is used by the garbage collector to
//! detect what data is still in use. The frames we've seen are
//!
//! # Limitations
//! Calling Julia is entirely single-threaded. You won't be able to use the [`Runtime`] from
//! another thread and while Julia is doing stuff you won't be able to interact with it.
//! Support for multithreading in Julia is currently in an experimental phase, there might still
//! be options to use this functionality in order to build experimental support for some kind of
//! multithreaded task-like system, but that has not been investigated yet.
//!
//! [`jl-sys`]: ../jl_sys/index.html
//! [`prelude`]: prelude/index.html
//! [`Runtime`]: struct.Runtime.html
//! [`Runtime::new`]: struct.Runtime.html#method.new
//! [`memory management`]: #memory-management
//! [`Runtime::include`]: struct.Runtime.html#method.include
//! [`Runtime::session`]: struct.Runtime.html#method.session
//! [`Session`]: context/struct.Session.html
//! [`Session::new_unassigned`]: context/struct.Session.html#method.new_unassigned
//! [`Session::new_primitive`]: context/struct.Session.html#method.new_primitive
//! [`Session::new_string`]: context/struct.Session.html#method.new_string
//! [`Session::new_owned_array`]: context/struct.Session.html#method.new_owned_array
//! [`Session::main_module`]: context/struct.Session.html#method.main_module
//! [`Session::base_module`]: context/struct.Session.html#method.base_module
//! [`Session::core_module`]: context/struct.Session.html#method.core_module
//! [`Module::submodule`]: data/module/struct.Module.html#method.submodule
//! [`Module::function`]: data/module/struct.Module.html#method.function
//! [`Session::execute`]: context/struct.Session.html#method.execute
//! [`ExecutionContext`]: context/struct.ExecutionContext.html
//! [`Call`]: traits/trait.Call.html
//! [`ExecutionContext::try_unbox`]: context/struct.ExecutionContext.html#method.try_unbox
//! [`Session::with_temporaries`]: context/struct.Session.html#method.with_temporaries
//! [`AllocationContext`]: context/struct.AllocationContext.html
//! [`AllocationContext::execute`]: context/struct.AllocationContext.html#method.execute
//! [`Runtime::set_stack_size`]: struct.Runtime.html#method.set_stack_size

pub mod array;
pub mod error;
pub mod frame;
mod memory;
pub mod module;
pub mod prelude;
pub mod traits;
pub mod value;

use error::{JlrsError, JlrsResult};
use frame::{DynamicFrame, StaticFrame};
use jl_sys::{jl_atexit_hook, jl_init};
use memory::{Dynamic, RawStack, StackView, Static};
use module::Module;
use std::mem::ManuallyDrop;
use std::path::Path;
use std::sync::atomic::{AtomicBool, Ordering};
use value::Value;

static INIT: AtomicBool = AtomicBool::new(false);

/// This struct can be created only once during the lifetime of your program. You
/// must create it with [`Runtime::new`] before you can do anything related to Julia.
///
/// [`Runtime::new`]: struct.Runtime.html#method.new
pub struct Runtime {
    stack: RawStack,
}

impl Runtime {
    /// Creates the `Runtime`. This function can only be called once because it initializes Julia.
    /// If you call it a second time, it will return an error. If this struct is dropped, you will
    /// need to restart your program to be able to call Julia code again.
    ///
    /// You have to choose a stack size when calling this function. This will be the total number
    /// of slots that will be available on the GC stack. One of these slots will alwas be in use,
    /// each level of nesting frames will take at least two slots,
    ///
    /// This function is unsafe because this crate provides you with a way to execute arbitrary
    /// Julia code.
    ///
    /// [`libary documentation`]: index.html
    #[cfg_attr(tarpaulin, skip)]
    pub unsafe fn new(stack_size: usize) -> JlrsResult<Self> {
        if INIT.swap(true, Ordering::SeqCst) {
            return Err(JlrsError::AlreadyInitialized.into());
        }

        jl_init();

        Ok(Runtime {
            stack: RawStack::new(stack_size),
        })
    }

    /// Change the stack size to `stack_size`.
    pub fn set_stack_size(&mut self, stack_size: usize) {
        unsafe { self.stack = RawStack::new(stack_size) }
    }

    /// Returns the stack size.
    pub fn stack_size(&self) -> usize {
        self.stack.size()
    }

    #[doc(hidden)]
    // DO NOT USE THIS. It's an awful, memory-leaking, workaround to make integration testing
    // easier
    pub unsafe fn testing_instance() -> ManuallyDrop<Runtime> {
        let mut rt = ManuallyDrop::new(Runtime {
            stack: RawStack::new(32),
        });

        if INIT.swap(true, Ordering::SeqCst) {
            return rt;
        }

        jl_init();
        rt.include("jlrs.jl").unwrap();
        rt
    }

    /// Calls `include` in the `Main` module in Julia, which executes the file's contents in that
    /// module. This has the same effect as calling `include` in the Julia REPL.
    ///
    /// Example:
    ///
    /// ```no_run
    /// # use jlrs::prelude::*;
    /// # fn main() {
    /// let mut runtime = unsafe { Runtime::new(16).unwrap() };
    /// runtime.include("jlrs.jl").unwrap();
    /// # }
    /// ```
    pub fn include<P: AsRef<Path>>(&mut self, path: P) -> JlrsResult<()> {
        if path.as_ref().exists() {
            return self.frame(3, |frame| {
                let path_jl_str = Value::new(frame, path.as_ref().to_string_lossy())?;
                let include_func = Module::main(frame).function("include")?;
                let _ = include_func.call1(frame, path_jl_str)?;
                Ok(())
            });
        }

        Err(JlrsError::IncludeNotFound(path.as_ref().to_string_lossy().into()).into())
    }

    /// Create a [`StaticFrame`] that can hold `capacity` values, and call the given closure.
    /// Returns the result of this closure, or an error if the new frame can't be created because
    /// there's not enough space on the GC stack. The number of required slots on the stack is
    /// `capacity + 2`.
    ///
    /// Every output and value you create inside the closure using the [`StaticFrame`], either
    /// directly or through calling a [`Value`], will reduce the available capacity of the
    /// [`StaticFrame`] by 1.
    ///
    /// Example:
    ///
    /// ```no_run
    /// # use jlrs::prelude::*;
    /// # fn main() {
    /// # let mut runtime = unsafe { Runtime::new(16).unwrap() };
    /// runtime.frame(2, |frame| {
    ///     let _i = Value::new(frame, 2u64)?;
    ///     let _j = Value::new(frame, 1u32)?;
    ///     Ok(())
    /// }).unwrap();
    /// # }
    /// ```
    ///
    /// [`StaticFrame`]: ../frame/struct.StaticFrame.html
    /// [`Value`]: ../value/struct.Value.html
    pub fn frame<T, F>(&mut self, capacity: usize, func: F) -> JlrsResult<T>
    where
        F: FnOnce(&mut StaticFrame<'_, '_>) -> JlrsResult<T>,
    {
        unsafe {
            let mut view = StackView::<Static>::new(self.stack.as_mut());
            let frame_idx = view.new_frame(capacity)?;
            let mut scope = frame::Scope;
            let mut frame = StaticFrame::with_capacity(frame_idx, capacity, view, &mut scope);
            func(&mut frame)
        }
    }

    /// Create a [`DynamicFrame`] and call the given closure. Returns the result of this closure,
    /// or an error if the new frame can't be created because the stack is too small. The number
    /// of required slots on the stack is 2.
    ///
    /// Every output and value you create inside the closure using the [`DynamicFrame`], either
    /// directly or through calling a [`Value`], will occupy a single slot on the GC stack.
    ///
    /// Example:
    ///
    /// ```no_run
    /// # use jlrs::prelude::*;
    /// # fn main() {
    /// # let mut runtime = unsafe { Runtime::new(16).unwrap() };
    /// runtime.dynamic_frame(|frame| {
    ///     let _i = Value::new(frame, 2u64)?;
    ///     let _j = Value::new(frame, 1u32)?;
    ///     Ok(())
    /// }).unwrap();
    /// # }
    /// ```
    ///
    /// [`DynamicFrame`]: ../frame/struct.DynamicFrame.html
    /// [`Value`]: ../value/struct.Value.html
    pub fn dynamic_frame<T, F>(&mut self, func: F) -> JlrsResult<T>
    where
        F: FnOnce(&mut DynamicFrame<'_, '_>) -> JlrsResult<T>,
    {
        unsafe {
            let mut view = StackView::<Dynamic>::new(self.stack.as_mut());
            let frame_idx = view.new_frame()?;
            let mut scope = frame::Scope;
            let mut frame = DynamicFrame::new(frame_idx, view, &mut scope);
            func(&mut frame)
        }
    }
}

impl Drop for Runtime {
    #[cfg_attr(tarpaulin, skip)]
    fn drop(&mut self) {
        unsafe {
            jl_atexit_hook(0);
        }
    }
}
