/* automatically generated by rust-bindgen */
/* generated from Julia version 1.4.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const TOP_BIT: i64 = -9223372036854775808;
pub const NBITS: u32 = 64;
pub const DBL_MAXINT: u64 = 9007199254740992;
pub const FLT_MAXINT: u32 = 16777216;
pub const U64_MAX: i32 = -1;
pub const S64_MAX: u64 = 9223372036854775807;
pub const S64_MIN: i64 = -9223372036854775808;
pub const BIT63: i64 = -9223372036854775808;
pub const U32_MAX: u32 = 4294967295;
pub const S32_MAX: u32 = 2147483647;
pub const S32_MIN: i32 = -2147483648;
pub const BIT31: u32 = 2147483648;
pub const UV__EOF: i32 = -4095;
pub const UV__UNKNOWN: i32 = -4094;
pub const UV__EAI_ADDRFAMILY: i32 = -3000;
pub const UV__EAI_AGAIN: i32 = -3001;
pub const UV__EAI_BADFLAGS: i32 = -3002;
pub const UV__EAI_CANCELED: i32 = -3003;
pub const UV__EAI_FAIL: i32 = -3004;
pub const UV__EAI_FAMILY: i32 = -3005;
pub const UV__EAI_MEMORY: i32 = -3006;
pub const UV__EAI_NODATA: i32 = -3007;
pub const UV__EAI_NONAME: i32 = -3008;
pub const UV__EAI_OVERFLOW: i32 = -3009;
pub const UV__EAI_SERVICE: i32 = -3010;
pub const UV__EAI_SOCKTYPE: i32 = -3011;
pub const UV__EAI_BADHINTS: i32 = -3013;
pub const UV__EAI_PROTOCOL: i32 = -3014;
pub const UV__ECHARSET: i32 = -4080;
pub const UV__EFTYPE: i32 = -4028;
pub const UV_VERSION_MAJOR: u32 = 2;
pub const UV_VERSION_MINOR: u32 = 0;
pub const UV_VERSION_PATCH: u32 = 0;
pub const UV_VERSION_IS_RELEASE: u32 = 0;
pub const UV_VERSION_SUFFIX: &'static [u8; 4usize] = b"dev\0";
pub const UV_VERSION_HEX: u32 = 131072;
pub const _SYS_STAT_H: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _STAT_VER_KERNEL: u32 = 0;
pub const _STAT_VER_LINUX: u32 = 1;
pub const _MKNOD_VER_LINUX: u32 = 0;
pub const _STAT_VER: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const _MKNOD_VER: u32 = 0;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const MAXNAMLEN: u32 = 255;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MAX: u32 = 45;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MAX: u32 = 45;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _NETINET_TCP_H: u32 = 1;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_CORK: u32 = 3;
pub const TCP_KEEPIDLE: u32 = 4;
pub const TCP_KEEPINTVL: u32 = 5;
pub const TCP_KEEPCNT: u32 = 6;
pub const TCP_SYNCNT: u32 = 7;
pub const TCP_LINGER2: u32 = 8;
pub const TCP_DEFER_ACCEPT: u32 = 9;
pub const TCP_WINDOW_CLAMP: u32 = 10;
pub const TCP_INFO: u32 = 11;
pub const TCP_QUICKACK: u32 = 12;
pub const TCP_CONGESTION: u32 = 13;
pub const TCP_MD5SIG: u32 = 14;
pub const TCP_COOKIE_TRANSACTIONS: u32 = 15;
pub const TCP_THIN_LINEAR_TIMEOUTS: u32 = 16;
pub const TCP_THIN_DUPACK: u32 = 17;
pub const TCP_USER_TIMEOUT: u32 = 18;
pub const TCP_REPAIR: u32 = 19;
pub const TCP_REPAIR_QUEUE: u32 = 20;
pub const TCP_QUEUE_SEQ: u32 = 21;
pub const TCP_REPAIR_OPTIONS: u32 = 22;
pub const TCP_FASTOPEN: u32 = 23;
pub const TCP_TIMESTAMP: u32 = 24;
pub const TCP_NOTSENT_LOWAT: u32 = 25;
pub const TCP_CC_INFO: u32 = 26;
pub const TCP_SAVE_SYN: u32 = 27;
pub const TCP_SAVED_SYN: u32 = 28;
pub const TCP_REPAIR_WINDOW: u32 = 29;
pub const TCP_FASTOPEN_CONNECT: u32 = 30;
pub const TCP_ULP: u32 = 31;
pub const TCP_MD5SIG_EXT: u32 = 32;
pub const TCP_FASTOPEN_KEY: u32 = 33;
pub const TCP_FASTOPEN_NO_COOKIE: u32 = 34;
pub const TCP_ZEROCOPY_RECEIVE: u32 = 35;
pub const TCP_INQ: u32 = 36;
pub const TCP_CM_INQ: u32 = 36;
pub const TCP_TX_DELAY: u32 = 37;
pub const TCP_REPAIR_ON: u32 = 1;
pub const TCP_REPAIR_OFF: u32 = 0;
pub const TCP_REPAIR_OFF_NO_WP: i32 = -1;
pub const TH_FIN: u32 = 1;
pub const TH_SYN: u32 = 2;
pub const TH_RST: u32 = 4;
pub const TH_PUSH: u32 = 8;
pub const TH_ACK: u32 = 16;
pub const TH_URG: u32 = 32;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_MAXSEG: u32 = 2;
pub const TCPOLEN_MAXSEG: u32 = 4;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERMITTED: u32 = 4;
pub const TCPOLEN_SACK_PERMITTED: u32 = 2;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_TSTAMP_APPA: u32 = 12;
pub const TCPOPT_TSTAMP_HDR: u32 = 16844810;
pub const TCP_MSS: u32 = 512;
pub const TCP_MAXWIN: u32 = 65535;
pub const TCP_MAX_WINSHIFT: u32 = 14;
pub const SOL_TCP: u32 = 6;
pub const TCPI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPI_OPT_SACK: u32 = 2;
pub const TCPI_OPT_WSCALE: u32 = 4;
pub const TCPI_OPT_ECN: u32 = 8;
pub const TCPI_OPT_ECN_SEEN: u32 = 16;
pub const TCPI_OPT_SYN_DATA: u32 = 32;
pub const TCP_MD5SIG_MAXKEYLEN: u32 = 80;
pub const TCP_MD5SIG_FLAG_PREFIX: u32 = 1;
pub const TCP_COOKIE_MIN: u32 = 8;
pub const TCP_COOKIE_MAX: u32 = 16;
pub const TCP_COOKIE_PAIR_SIZE: u32 = 32;
pub const TCP_COOKIE_IN_ALWAYS: u32 = 1;
pub const TCP_COOKIE_OUT_NEVER: u32 = 2;
pub const TCP_S_DATA_IN: u32 = 4;
pub const TCP_S_DATA_OUT: u32 = 8;
pub const TCP_MSS_DEFAULT: u32 = 536;
pub const TCP_MSS_DESIRED: u32 = 1220;
pub const _ARPA_INET_H: u32 = 1;
pub const _NETDB_H: u32 = 1;
pub const _RPC_NETDB_H: u32 = 1;
pub const _PATH_HEQUIV: &'static [u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &'static [u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &'static [u8; 14usize] = b"/etc/networks\0";
pub const _PATH_NSSWITCH_CONF: &'static [u8; 19usize] = b"/etc/nsswitch.conf\0";
pub const _PATH_PROTOCOLS: &'static [u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &'static [u8; 14usize] = b"/etc/services\0";
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const NO_ADDRESS: u32 = 4;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const AI_NUMERICSERV: u32 = 1024;
pub const EAI_BADFLAGS: i32 = -1;
pub const EAI_NONAME: i32 = -2;
pub const EAI_AGAIN: i32 = -3;
pub const EAI_FAIL: i32 = -4;
pub const EAI_FAMILY: i32 = -6;
pub const EAI_SOCKTYPE: i32 = -7;
pub const EAI_SERVICE: i32 = -8;
pub const EAI_MEMORY: i32 = -10;
pub const EAI_SYSTEM: i32 = -11;
pub const EAI_OVERFLOW: i32 = -12;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NUMERICHOST: u32 = 1;
pub const NI_NUMERICSERV: u32 = 2;
pub const NI_NOFQDN: u32 = 4;
pub const NI_NAMEREQD: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const _TERMIOS_H: u32 = 1;
pub const NCCS: u32 = 32;
pub const _HAVE_STRUCT_TERMIOS_C_ISPEED: u32 = 1;
pub const _HAVE_STRUCT_TERMIOS_C_OSPEED: u32 = 1;
pub const VINTR: u32 = 0;
pub const VQUIT: u32 = 1;
pub const VERASE: u32 = 2;
pub const VKILL: u32 = 3;
pub const VEOF: u32 = 4;
pub const VTIME: u32 = 5;
pub const VMIN: u32 = 6;
pub const VSWTC: u32 = 7;
pub const VSTART: u32 = 8;
pub const VSTOP: u32 = 9;
pub const VSUSP: u32 = 10;
pub const VEOL: u32 = 11;
pub const VREPRINT: u32 = 12;
pub const VDISCARD: u32 = 13;
pub const VWERASE: u32 = 14;
pub const VLNEXT: u32 = 15;
pub const VEOL2: u32 = 16;
pub const IGNBRK: u32 = 1;
pub const BRKINT: u32 = 2;
pub const IGNPAR: u32 = 4;
pub const PARMRK: u32 = 8;
pub const INPCK: u32 = 16;
pub const ISTRIP: u32 = 32;
pub const INLCR: u32 = 64;
pub const IGNCR: u32 = 128;
pub const ICRNL: u32 = 256;
pub const IUCLC: u32 = 512;
pub const IXON: u32 = 1024;
pub const IXANY: u32 = 2048;
pub const IXOFF: u32 = 4096;
pub const IMAXBEL: u32 = 8192;
pub const IUTF8: u32 = 16384;
pub const OPOST: u32 = 1;
pub const OLCUC: u32 = 2;
pub const ONLCR: u32 = 4;
pub const OCRNL: u32 = 8;
pub const ONOCR: u32 = 16;
pub const ONLRET: u32 = 32;
pub const OFILL: u32 = 64;
pub const OFDEL: u32 = 128;
pub const NLDLY: u32 = 256;
pub const NL0: u32 = 0;
pub const NL1: u32 = 256;
pub const CRDLY: u32 = 1536;
pub const CR0: u32 = 0;
pub const CR1: u32 = 512;
pub const CR2: u32 = 1024;
pub const CR3: u32 = 1536;
pub const TABDLY: u32 = 6144;
pub const TAB0: u32 = 0;
pub const TAB1: u32 = 2048;
pub const TAB2: u32 = 4096;
pub const TAB3: u32 = 6144;
pub const BSDLY: u32 = 8192;
pub const BS0: u32 = 0;
pub const BS1: u32 = 8192;
pub const FFDLY: u32 = 32768;
pub const FF0: u32 = 0;
pub const FF1: u32 = 32768;
pub const VTDLY: u32 = 16384;
pub const VT0: u32 = 0;
pub const VT1: u32 = 16384;
pub const XTABS: u32 = 6144;
pub const B0: u32 = 0;
pub const B50: u32 = 1;
pub const B75: u32 = 2;
pub const B110: u32 = 3;
pub const B134: u32 = 4;
pub const B150: u32 = 5;
pub const B200: u32 = 6;
pub const B300: u32 = 7;
pub const B600: u32 = 8;
pub const B1200: u32 = 9;
pub const B1800: u32 = 10;
pub const B2400: u32 = 11;
pub const B4800: u32 = 12;
pub const B9600: u32 = 13;
pub const B19200: u32 = 14;
pub const B38400: u32 = 15;
pub const EXTA: u32 = 14;
pub const EXTB: u32 = 15;
pub const CBAUD: u32 = 4111;
pub const CBAUDEX: u32 = 4096;
pub const CIBAUD: u32 = 269418496;
pub const CMSPAR: u32 = 1073741824;
pub const CRTSCTS: u32 = 2147483648;
pub const B57600: u32 = 4097;
pub const B115200: u32 = 4098;
pub const B230400: u32 = 4099;
pub const B460800: u32 = 4100;
pub const B500000: u32 = 4101;
pub const B576000: u32 = 4102;
pub const B921600: u32 = 4103;
pub const B1000000: u32 = 4104;
pub const B1152000: u32 = 4105;
pub const B1500000: u32 = 4106;
pub const B2000000: u32 = 4107;
pub const B2500000: u32 = 4108;
pub const B3000000: u32 = 4109;
pub const B3500000: u32 = 4110;
pub const B4000000: u32 = 4111;
pub const __MAX_BAUD: u32 = 4111;
pub const CSIZE: u32 = 48;
pub const CS5: u32 = 0;
pub const CS6: u32 = 16;
pub const CS7: u32 = 32;
pub const CS8: u32 = 48;
pub const CSTOPB: u32 = 64;
pub const CREAD: u32 = 128;
pub const PARENB: u32 = 256;
pub const PARODD: u32 = 512;
pub const HUPCL: u32 = 1024;
pub const CLOCAL: u32 = 2048;
pub const ISIG: u32 = 1;
pub const ICANON: u32 = 2;
pub const XCASE: u32 = 4;
pub const ECHO: u32 = 8;
pub const ECHOE: u32 = 16;
pub const ECHOK: u32 = 32;
pub const ECHONL: u32 = 64;
pub const NOFLSH: u32 = 128;
pub const TOSTOP: u32 = 256;
pub const ECHOCTL: u32 = 512;
pub const ECHOPRT: u32 = 1024;
pub const ECHOKE: u32 = 2048;
pub const FLUSHO: u32 = 4096;
pub const PENDIN: u32 = 16384;
pub const IEXTEN: u32 = 32768;
pub const EXTPROC: u32 = 65536;
pub const TIOCSER_TEMT: u32 = 1;
pub const TCOOFF: u32 = 0;
pub const TCOON: u32 = 1;
pub const TCIOFF: u32 = 2;
pub const TCION: u32 = 3;
pub const TCIFLUSH: u32 = 0;
pub const TCOFLUSH: u32 = 1;
pub const TCIOFLUSH: u32 = 2;
pub const TCSANOW: u32 = 0;
pub const TCSADRAIN: u32 = 1;
pub const TCSAFLUSH: u32 = 2;
pub const TTYDEF_IFLAG: u32 = 11554;
pub const TTYDEF_OFLAG: u32 = 6149;
pub const TTYDEF_LFLAG: u32 = 35355;
pub const TTYDEF_CFLAG: u32 = 1440;
pub const TTYDEF_SPEED: u32 = 13;
pub const CEOL: u8 = 0u8;
pub const CERASE: u32 = 127;
pub const CSTATUS: u8 = 0u8;
pub const CMIN: u32 = 1;
pub const CQUIT: u32 = 28;
pub const CTIME: u32 = 0;
pub const CBRK: u8 = 0u8;
pub const _PWD_H: u32 = 1;
pub const NSS_BUFLEN_PASSWD: u32 = 1024;
pub const _SEMAPHORE_H: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 32;
pub const _SYS_PARAM_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _BITS_SIGNUM_H: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 23;
pub const SIGIOT: u32 = 6;
pub const SIGCLD: u32 = 20;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 32;
pub const _NSIG: u32 = 33;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 33;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const HZ: u32 = 100;
pub const EXEC_PAGESIZE: u32 = 4096;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const MAXSYMLINKS: u32 = 20;
pub const NOFILE: u32 = 256;
pub const NCARGS: u32 = 131072;
pub const NGROUPS: u32 = 65536;
pub const CANBSIZ: u32 = 255;
pub const MAXPATHLEN: u32 = 4096;
pub const DEV_BSIZE: u32 = 512;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const UV_ONCE_INIT: u32 = 0;
pub const UV_FS_O_APPEND: u32 = 1024;
pub const UV_FS_O_CREAT: u32 = 64;
pub const UV_FS_O_DIRECT: u32 = 0;
pub const UV_FS_O_DIRECTORY: u32 = 65536;
pub const UV_FS_O_DSYNC: u32 = 4096;
pub const UV_FS_O_EXCL: u32 = 128;
pub const UV_FS_O_EXLOCK: u32 = 0;
pub const UV_FS_O_NOATIME: u32 = 0;
pub const UV_FS_O_NOCTTY: u32 = 256;
pub const UV_FS_O_NOFOLLOW: u32 = 131072;
pub const UV_FS_O_NONBLOCK: u32 = 2048;
pub const UV_FS_O_RDONLY: u32 = 0;
pub const UV_FS_O_RDWR: u32 = 2;
pub const UV_FS_O_SYMLINK: u32 = 0;
pub const UV_FS_O_SYNC: u32 = 1052672;
pub const UV_FS_O_TRUNC: u32 = 512;
pub const UV_FS_O_WRONLY: u32 = 1;
pub const UV_FS_O_RANDOM: u32 = 0;
pub const UV_FS_O_SHORT_LIVED: u32 = 0;
pub const UV_FS_O_SEQUENTIAL: u32 = 0;
pub const UV_FS_O_TEMPORARY: u32 = 0;
pub const UV_STDIN_FD: u32 = 0;
pub const UV_STDOUT_FD: u32 = 1;
pub const UV_STDERR_FD: u32 = 2;
pub const UV_PRIORITY_LOW: u32 = 19;
pub const UV_PRIORITY_BELOW_NORMAL: u32 = 10;
pub const UV_PRIORITY_NORMAL: u32 = 0;
pub const UV_PRIORITY_ABOVE_NORMAL: i32 = -7;
pub const UV_PRIORITY_HIGH: i32 = -14;
pub const UV_PRIORITY_HIGHEST: i32 = -20;
pub const UV_MAXHOSTNAMESIZE: u32 = 65;
pub const UV_FS_COPYFILE_EXCL: u32 = 1;
pub const UV_FS_COPYFILE_FICLONE: u32 = 2;
pub const UV_FS_COPYFILE_FICLONE_FORCE: u32 = 4;
pub const UV_FS_SYMLINK_DIR: u32 = 1;
pub const UV_FS_SYMLINK_JUNCTION: u32 = 2;
pub const UV_IF_NAMESIZE: u32 = 17;
pub const IOS_INLSIZE: u32 = 54;
pub const IOS_BUFSIZE: u32 = 131072;
pub const IOS_EOF: i32 = -1;
pub const HT_N_INLINE: u32 = 32;
pub const PATHSEPSTRING: &'static [u8; 2usize] = b"/\0";
pub const PATHLISTSEPSTRING: &'static [u8; 2usize] = b":\0";
pub const AL_N_INLINE: u32 = 29;
pub const _SETJMP_H: u32 = 1;
pub const MAX_ALIGN: u32 = 8;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const _CMP_EQ_OQ: u32 = 0;
pub const _CMP_LT_OS: u32 = 1;
pub const _CMP_LE_OS: u32 = 2;
pub const _CMP_UNORD_Q: u32 = 3;
pub const _CMP_NEQ_UQ: u32 = 4;
pub const _CMP_NLT_US: u32 = 5;
pub const _CMP_NLE_US: u32 = 6;
pub const _CMP_ORD_Q: u32 = 7;
pub const _CMP_EQ_UQ: u32 = 8;
pub const _CMP_NGE_US: u32 = 9;
pub const _CMP_NGT_US: u32 = 10;
pub const _CMP_FALSE_OQ: u32 = 11;
pub const _CMP_NEQ_OQ: u32 = 12;
pub const _CMP_GE_OS: u32 = 13;
pub const _CMP_GT_OS: u32 = 14;
pub const _CMP_TRUE_UQ: u32 = 15;
pub const _CMP_EQ_OS: u32 = 16;
pub const _CMP_LT_OQ: u32 = 17;
pub const _CMP_LE_OQ: u32 = 18;
pub const _CMP_UNORD_S: u32 = 19;
pub const _CMP_NEQ_US: u32 = 20;
pub const _CMP_NLT_UQ: u32 = 21;
pub const _CMP_NLE_UQ: u32 = 22;
pub const _CMP_ORD_S: u32 = 23;
pub const _CMP_EQ_US: u32 = 24;
pub const _CMP_NGE_UQ: u32 = 25;
pub const _CMP_NGT_UQ: u32 = 26;
pub const _CMP_FALSE_OS: u32 = 27;
pub const _CMP_NEQ_OS: u32 = 28;
pub const _CMP_GE_OQ: u32 = 29;
pub const _CMP_GT_OQ: u32 = 30;
pub const _CMP_TRUE_US: u32 = 31;
pub const _XBEGIN_STARTED: i32 = -1;
pub const _XABORT_EXPLICIT: u32 = 1;
pub const _XABORT_RETRY: u32 = 2;
pub const _XABORT_CONFLICT: u32 = 4;
pub const _XABORT_CAPACITY: u32 = 8;
pub const _XABORT_DEBUG: u32 = 16;
pub const _XABORT_NESTED: u32 = 32;
pub const __PCONFIG_KEY_PROGRAM: u32 = 1;
pub const JL_GC_N_POOLS: u32 = 41;
pub const JL_N_STACK_POOLS: u32 = 16;
pub const JL_MAX_BT_SIZE: u32 = 80000;
pub const JL_GC_STATE_WAITING: u32 = 1;
pub const JL_GC_STATE_SAFE: u32 = 2;
pub const JL_CPU_WAKE_NOOP: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const jl_setjmp_name: &'static [u8; 12usize] = b"__sigsetjmp\0";
pub const JL_LOG_NONE: u32 = 0;
pub const JL_LOG_USER: u32 = 1;
pub const JL_LOG_ALL: u32 = 2;
pub const JL_OPTIONS_CHECK_BOUNDS_DEFAULT: u32 = 0;
pub const JL_OPTIONS_CHECK_BOUNDS_ON: u32 = 1;
pub const JL_OPTIONS_CHECK_BOUNDS_OFF: u32 = 2;
pub const JL_OPTIONS_COMPILE_DEFAULT: u32 = 1;
pub const JL_OPTIONS_COMPILE_OFF: u32 = 0;
pub const JL_OPTIONS_COMPILE_ON: u32 = 1;
pub const JL_OPTIONS_COMPILE_ALL: u32 = 2;
pub const JL_OPTIONS_COMPILE_MIN: u32 = 3;
pub const JL_OPTIONS_COLOR_AUTO: u32 = 0;
pub const JL_OPTIONS_COLOR_ON: u32 = 1;
pub const JL_OPTIONS_COLOR_OFF: u32 = 2;
pub const JL_OPTIONS_HISTORYFILE_ON: u32 = 1;
pub const JL_OPTIONS_HISTORYFILE_OFF: u32 = 0;
pub const JL_OPTIONS_STARTUPFILE_ON: u32 = 1;
pub const JL_OPTIONS_STARTUPFILE_OFF: u32 = 2;
pub const JL_LOGLEVEL_BELOWMIN: i32 = -1000001;
pub const JL_LOGLEVEL_DEBUG: i32 = -1000;
pub const JL_LOGLEVEL_INFO: u32 = 0;
pub const JL_LOGLEVEL_WARN: u32 = 1000;
pub const JL_LOGLEVEL_ERROR: u32 = 2000;
pub const JL_LOGLEVEL_ABOVEMAX: u32 = 1000001;
pub const JL_OPTIONS_DEPWARN_OFF: u32 = 0;
pub const JL_OPTIONS_DEPWARN_ON: u32 = 1;
pub const JL_OPTIONS_DEPWARN_ERROR: u32 = 2;
pub const JL_OPTIONS_WARN_OVERWRITE_OFF: u32 = 0;
pub const JL_OPTIONS_WARN_OVERWRITE_ON: u32 = 1;
pub const JL_OPTIONS_POLLY_ON: u32 = 1;
pub const JL_OPTIONS_POLLY_OFF: u32 = 0;
pub const JL_OPTIONS_FAST_MATH_ON: u32 = 1;
pub const JL_OPTIONS_FAST_MATH_OFF: u32 = 2;
pub const JL_OPTIONS_FAST_MATH_DEFAULT: u32 = 0;
pub const JL_OPTIONS_HANDLE_SIGNALS_ON: u32 = 1;
pub const JL_OPTIONS_HANDLE_SIGNALS_OFF: u32 = 0;
pub const JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_YES: u32 = 1;
pub const JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_NO: u32 = 0;
pub const JL_OPTIONS_USE_COMPILED_MODULES_YES: u32 = 1;
pub const JL_OPTIONS_USE_COMPILED_MODULES_NO: u32 = 0;
pub const JULIA_VERSION_STRING: &'static [u8; 6usize] = b"1.4.1\0";
pub const JULIA_VERSION_MAJOR: u32 = 1;
pub const JULIA_VERSION_MINOR: u32 = 4;
pub const JULIA_VERSION_PATCH: u32 = 1;
pub const JULIA_VERSION_IS_RELEASE: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = 0;
pub const FP_INFINITE: _bindgen_ty_1 = 1;
pub const FP_ZERO: _bindgen_ty_1 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = u32;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type bool_t = ::std::os::raw::c_int;
pub type byte_t = ::std::os::raw::c_uchar;
pub type uint_t = u64;
pub type int_t = i64;
pub const numerictype_t_T_INT8: numerictype_t = 0;
pub const numerictype_t_T_UINT8: numerictype_t = 1;
pub const numerictype_t_T_INT16: numerictype_t = 2;
pub const numerictype_t_T_UINT16: numerictype_t = 3;
pub const numerictype_t_T_INT32: numerictype_t = 4;
pub const numerictype_t_T_UINT32: numerictype_t = 5;
pub const numerictype_t_T_INT64: numerictype_t = 6;
pub const numerictype_t_T_UINT64: numerictype_t = 7;
pub const numerictype_t_T_FLOAT: numerictype_t = 8;
pub const numerictype_t_T_DOUBLE: numerictype_t = 9;
pub type numerictype_t = u32;
extern "C" {
    pub fn uint2str(
        dest: *mut ::std::os::raw::c_char,
        len: usize,
        num: u64,
        base: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn str2int(
        str: *mut ::std::os::raw::c_char,
        len: usize,
        res: *mut i64,
        base: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_base(
        c: ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn conv_to_double(data: *mut ::std::os::raw::c_void, tag: numerictype_t) -> f64;
}
extern "C" {
    pub fn conv_to_int64(data: *mut ::std::os::raw::c_void, tag: numerictype_t) -> i64;
}
extern "C" {
    pub fn conv_to_uint64(data: *mut ::std::os::raw::c_void, tag: numerictype_t) -> u64;
}
extern "C" {
    pub fn conv_to_int32(data: *mut ::std::os::raw::c_void, tag: numerictype_t) -> i32;
}
extern "C" {
    pub fn conv_to_uint32(data: *mut ::std::os::raw::c_void, tag: numerictype_t) -> u32;
}
extern "C" {
    pub fn cmp_same_lt(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        tag: numerictype_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmp_same_eq(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        tag: numerictype_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmp_lt(
        a: *mut ::std::os::raw::c_void,
        atag: numerictype_t,
        b: *mut ::std::os::raw::c_void,
        btag: numerictype_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmp_eq(
        a: *mut ::std::os::raw::c_void,
        atag: numerictype_t,
        b: *mut ::std::os::raw::c_void,
        btag: numerictype_t,
        equalnans: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn u8_toucs(
        dest: *mut u32,
        sz: usize,
        src: *const ::std::os::raw::c_char,
        srcsz: usize,
    ) -> usize;
}
extern "C" {
    pub fn u8_toutf8(
        dest: *mut ::std::os::raw::c_char,
        sz: usize,
        src: *const u32,
        srcsz: usize,
    ) -> usize;
}
extern "C" {
    pub fn u8_wc_toutf8(dest: *mut ::std::os::raw::c_char, ch: u32) -> usize;
}
extern "C" {
    pub fn u8_offset(str: *const ::std::os::raw::c_char, charnum: usize) -> usize;
}
extern "C" {
    pub fn u8_charnum(str: *const ::std::os::raw::c_char, offset: usize) -> usize;
}
extern "C" {
    pub fn u8_nextchar(s: *const ::std::os::raw::c_char, i: *mut usize) -> u32;
}
extern "C" {
    pub fn u8_nextmemchar(s: *const ::std::os::raw::c_char, i: *mut usize) -> u32;
}
extern "C" {
    pub fn u8_inc(s: *const ::std::os::raw::c_char, i: *mut usize);
}
extern "C" {
    pub fn u8_dec(s: *const ::std::os::raw::c_char, i: *mut usize);
}
extern "C" {
    pub fn u8_seqlen(s: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn u8_charlen(ch: u32) -> usize;
}
extern "C" {
    pub fn read_escape_control_char(c: ::std::os::raw::c_char) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn u8_read_escape_sequence(
        src: *const ::std::os::raw::c_char,
        ssz: usize,
        dest: *mut u32,
    ) -> usize;
}
extern "C" {
    pub fn u8_escape_wchar(
        buf: *mut ::std::os::raw::c_char,
        sz: usize,
        ch: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn u8_escape(
        buf: *mut ::std::os::raw::c_char,
        sz: usize,
        src: *const ::std::os::raw::c_char,
        pi: *mut usize,
        end: usize,
        escape_quotes: ::std::os::raw::c_int,
        ascii: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    pub fn octal_digit(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hex_digit(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn u8_memchr(
        s: *const ::std::os::raw::c_char,
        ch: u32,
        sz: usize,
        charn: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u8_memrchr(
        s: *const ::std::os::raw::c_char,
        ch: u32,
        sz: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u8_strwidth(s: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn u8_vprintf(fmt: *const ::std::os::raw::c_char, ap: *mut __va_list_tag) -> usize;
}
extern "C" {
    pub fn u8_printf(fmt: *const ::std::os::raw::c_char, ...) -> usize;
}
extern "C" {
    pub fn u8_isvalid(str: *const ::std::os::raw::c_char, length: usize) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstat(
        __ver: ::std::os::raw::c_int,
        __fildes: ::std::os::raw::c_int,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xstat(
        __ver: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lxstat(
        __ver: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstatat(
        __ver: ::std::os::raw::c_int,
        __fildes: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknod(
        __ver: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknodat(
        __ver: ::std::os::raw::c_int,
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_whence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
extern "C" {
    pub fn fcntl(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fallocate(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        280usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_type as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_name as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
pub const DT_UNKNOWN: _bindgen_ty_2 = 0;
pub const DT_FIFO: _bindgen_ty_2 = 1;
pub const DT_CHR: _bindgen_ty_2 = 2;
pub const DT_DIR: _bindgen_ty_2 = 4;
pub const DT_BLK: _bindgen_ty_2 = 6;
pub const DT_REG: _bindgen_ty_2 = 8;
pub const DT_LNK: _bindgen_ty_2 = 10;
pub const DT_SOCK: _bindgen_ty_2 = 12;
pub const DT_WHT: _bindgen_ty_2 = 14;
pub type _bindgen_ty_2 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = u32;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
pub const MSG_OOB: _bindgen_ty_3 = 1;
pub const MSG_PEEK: _bindgen_ty_3 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_3 = 4;
pub const MSG_CTRUNC: _bindgen_ty_3 = 8;
pub const MSG_PROXY: _bindgen_ty_3 = 16;
pub const MSG_TRUNC: _bindgen_ty_3 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_3 = 64;
pub const MSG_EOR: _bindgen_ty_3 = 128;
pub const MSG_WAITALL: _bindgen_ty_3 = 256;
pub const MSG_FIN: _bindgen_ty_3 = 512;
pub const MSG_SYN: _bindgen_ty_3 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_3 = 2048;
pub const MSG_RST: _bindgen_ty_3 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_3 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_3 = 16384;
pub const MSG_MORE: _bindgen_ty_3 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_3 = 65536;
pub const MSG_BATCH: _bindgen_ty_3 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_3 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_3 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_3 = 1073741824;
pub type _bindgen_ty_3 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).__cmsg_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_4 = 1;
pub type _bindgen_ty_4 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: _bindgen_ty_5 = 0;
pub const SHUT_WR: _bindgen_ty_5 = 1;
pub const SHUT_RDWR: _bindgen_ty_5 = 2;
pub type _bindgen_ty_5 = u32;
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
pub const IPPROTO_IP: _bindgen_ty_6 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_6 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_6 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_6 = 4;
pub const IPPROTO_TCP: _bindgen_ty_6 = 6;
pub const IPPROTO_EGP: _bindgen_ty_6 = 8;
pub const IPPROTO_PUP: _bindgen_ty_6 = 12;
pub const IPPROTO_UDP: _bindgen_ty_6 = 17;
pub const IPPROTO_IDP: _bindgen_ty_6 = 22;
pub const IPPROTO_TP: _bindgen_ty_6 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_6 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_6 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_6 = 46;
pub const IPPROTO_GRE: _bindgen_ty_6 = 47;
pub const IPPROTO_ESP: _bindgen_ty_6 = 50;
pub const IPPROTO_AH: _bindgen_ty_6 = 51;
pub const IPPROTO_MTP: _bindgen_ty_6 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_6 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_6 = 98;
pub const IPPROTO_PIM: _bindgen_ty_6 = 103;
pub const IPPROTO_COMP: _bindgen_ty_6 = 108;
pub const IPPROTO_SCTP: _bindgen_ty_6 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_6 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_6 = 137;
pub const IPPROTO_RAW: _bindgen_ty_6 = 255;
pub const IPPROTO_MAX: _bindgen_ty_6 = 256;
pub type _bindgen_ty_6 = u32;
pub const IPPROTO_HOPOPTS: _bindgen_ty_7 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_7 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_7 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_7 = 58;
pub const IPPROTO_NONE: _bindgen_ty_7 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_7 = 60;
pub const IPPROTO_MH: _bindgen_ty_7 = 135;
pub type _bindgen_ty_7 = u32;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_8 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_8 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_8 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_8 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_8 = 15;
pub const IPPORT_FTP: _bindgen_ty_8 = 21;
pub const IPPORT_TELNET: _bindgen_ty_8 = 23;
pub const IPPORT_SMTP: _bindgen_ty_8 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_8 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_8 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_8 = 43;
pub const IPPORT_MTP: _bindgen_ty_8 = 57;
pub const IPPORT_TFTP: _bindgen_ty_8 = 69;
pub const IPPORT_RJE: _bindgen_ty_8 = 77;
pub const IPPORT_FINGER: _bindgen_ty_8 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_8 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_8 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_8 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_8 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_8 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_8 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_8 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_8 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_8 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_8 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_8 = 5000;
pub type _bindgen_ty_8 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_source as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_fmode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_numsrc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_slist as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_fmode as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_numsrc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_slist as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
pub type tcp_seq = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcphdr {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: tcphdr__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 {
    pub th_sport: u16,
    pub th_dport: u16,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub th_flags: u8,
    pub th_win: u16,
    pub th_sum: u16,
    pub th_urp: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_sport as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_dport as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_dport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_seq as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_ack as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_ack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_flags as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_win as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_win)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_sum as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_urp as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_urp)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn th_x2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn th_off(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u8, th_off: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u8 = unsafe { ::std::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u8 = unsafe { ::std::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 {
    pub source: u16,
    pub dest: u16,
    pub seq: u32,
    pub ack_seq: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub window: u16,
    pub check: u16,
    pub urg_ptr: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).source as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).dest as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).seq as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).ack_seq as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ack_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).window as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).check as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).urg_ptr as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(urg_ptr)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: u16,
        doff: u16,
        fin: u16,
        syn: u16,
        rst: u16,
        psh: u16,
        ack: u16,
        urg: u16,
        res2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::std::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::std::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::std::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::std::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::std::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::std::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::std::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr))
    );
}
pub const TCP_ESTABLISHED: _bindgen_ty_9 = 1;
pub const TCP_SYN_SENT: _bindgen_ty_9 = 2;
pub const TCP_SYN_RECV: _bindgen_ty_9 = 3;
pub const TCP_FIN_WAIT1: _bindgen_ty_9 = 4;
pub const TCP_FIN_WAIT2: _bindgen_ty_9 = 5;
pub const TCP_TIME_WAIT: _bindgen_ty_9 = 6;
pub const TCP_CLOSE: _bindgen_ty_9 = 7;
pub const TCP_CLOSE_WAIT: _bindgen_ty_9 = 8;
pub const TCP_LAST_ACK: _bindgen_ty_9 = 9;
pub const TCP_LISTEN: _bindgen_ty_9 = 10;
pub const TCP_CLOSING: _bindgen_ty_9 = 11;
pub type _bindgen_ty_9 = u32;
pub const tcp_ca_state_TCP_CA_Open: tcp_ca_state = 0;
pub const tcp_ca_state_TCP_CA_Disorder: tcp_ca_state = 1;
pub const tcp_ca_state_TCP_CA_CWR: tcp_ca_state = 2;
pub const tcp_ca_state_TCP_CA_Recovery: tcp_ca_state = 3;
pub const tcp_ca_state_TCP_CA_Loss: tcp_ca_state = 4;
pub type tcp_ca_state = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_info {
    pub tcpi_state: u8,
    pub tcpi_ca_state: u8,
    pub tcpi_retransmits: u8,
    pub tcpi_probes: u8,
    pub tcpi_backoff: u8,
    pub tcpi_options: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub tcpi_rto: u32,
    pub tcpi_ato: u32,
    pub tcpi_snd_mss: u32,
    pub tcpi_rcv_mss: u32,
    pub tcpi_unacked: u32,
    pub tcpi_sacked: u32,
    pub tcpi_lost: u32,
    pub tcpi_retrans: u32,
    pub tcpi_fackets: u32,
    pub tcpi_last_data_sent: u32,
    pub tcpi_last_ack_sent: u32,
    pub tcpi_last_data_recv: u32,
    pub tcpi_last_ack_recv: u32,
    pub tcpi_pmtu: u32,
    pub tcpi_rcv_ssthresh: u32,
    pub tcpi_rtt: u32,
    pub tcpi_rttvar: u32,
    pub tcpi_snd_ssthresh: u32,
    pub tcpi_snd_cwnd: u32,
    pub tcpi_advmss: u32,
    pub tcpi_reordering: u32,
    pub tcpi_rcv_rtt: u32,
    pub tcpi_rcv_space: u32,
    pub tcpi_total_retrans: u32,
}
#[test]
fn bindgen_test_layout_tcp_info() {
    assert_eq!(
        ::std::mem::size_of::<tcp_info>(),
        104usize,
        concat!("Size of: ", stringify!(tcp_info))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_ca_state as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ca_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_retransmits as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retransmits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_probes as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_probes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_backoff as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_backoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_options as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rto as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_ato as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ato)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_snd_mss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_mss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rcv_mss as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_mss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_unacked as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_unacked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_sacked as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_sacked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_lost as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_lost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_retrans as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_fackets as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_fackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_last_data_sent as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_sent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_last_ack_sent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_sent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_last_data_recv as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_last_ack_recv as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_pmtu as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_pmtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rcv_ssthresh as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_ssthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rtt as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rtt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rttvar as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rttvar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_snd_ssthresh as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_ssthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_snd_cwnd as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_cwnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_advmss as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_advmss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_reordering as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_reordering)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rcv_rtt as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_rtt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rcv_space as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_total_retrans as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_total_retrans)
        )
    );
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_snd_wscale: u8,
        tcpi_rcv_wscale: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tcpi_snd_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_snd_wscale) };
            tcpi_snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tcpi_rcv_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_rcv_wscale) };
            tcpi_rcv_wscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_md5sig {
    pub tcpm_addr: sockaddr_storage,
    pub tcpm_flags: u8,
    pub tcpm_prefixlen: u8,
    pub tcpm_keylen: u16,
    pub __tcpm_pad: u32,
    pub tcpm_key: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_tcp_md5sig() {
    assert_eq!(
        ::std::mem::size_of::<tcp_md5sig>(),
        216usize,
        concat!("Size of: ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_md5sig>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_prefixlen as *const _ as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_prefixlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_keylen as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_keylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).__tcpm_pad as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(__tcpm_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_key as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_opt {
    pub opt_code: u32,
    pub opt_val: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_opt() {
    assert_eq!(
        ::std::mem::size_of::<tcp_repair_opt>(),
        8usize,
        concat!("Size of: ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_repair_opt>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_opt>())).opt_code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_opt>())).opt_val as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_val)
        )
    );
}
pub const TCP_NO_QUEUE: _bindgen_ty_10 = 0;
pub const TCP_RECV_QUEUE: _bindgen_ty_10 = 1;
pub const TCP_SEND_QUEUE: _bindgen_ty_10 = 2;
pub const TCP_QUEUES_NR: _bindgen_ty_10 = 3;
pub type _bindgen_ty_10 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_cookie_transactions {
    pub tcpct_flags: u16,
    pub __tcpct_pad1: u8,
    pub tcpct_cookie_desired: u8,
    pub tcpct_s_data_desired: u16,
    pub tcpct_used: u16,
    pub tcpct_value: [u8; 536usize],
}
#[test]
fn bindgen_test_layout_tcp_cookie_transactions() {
    assert_eq!(
        ::std::mem::size_of::<tcp_cookie_transactions>(),
        544usize,
        concat!("Size of: ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_cookie_transactions>(),
        2usize,
        concat!("Alignment of ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).__tcpct_pad1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(__tcpct_pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_cookie_desired as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_cookie_desired)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_s_data_desired as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_s_data_desired)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_used as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_value as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_window {
    pub snd_wl1: u32,
    pub snd_wnd: u32,
    pub max_window: u32,
    pub rcv_wnd: u32,
    pub rcv_wup: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_window() {
    assert_eq!(
        ::std::mem::size_of::<tcp_repair_window>(),
        20usize,
        concat!("Size of: ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_repair_window>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).snd_wl1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wl1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).snd_wnd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).max_window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(max_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).rcv_wnd as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).rcv_wup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_zerocopy_receive {
    pub address: u64,
    pub length: u32,
    pub recv_skip_hint: u32,
}
#[test]
fn bindgen_test_layout_tcp_zerocopy_receive() {
    assert_eq!(
        ::std::mem::size_of::<tcp_zerocopy_receive>(),
        16usize,
        concat!("Size of: ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_zerocopy_receive>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_zerocopy_receive>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_zerocopy_receive>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_zerocopy_receive>())).recv_skip_hint as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(recv_skip_hint)
        )
    );
}
extern "C" {
    pub fn inet_addr(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_lnaof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) -> in_addr;
}
extern "C" {
    pub fn inet_netof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_network(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_ntoa(__in: in_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __len: socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_aton(
        __cp: *const ::std::os::raw::c_char,
        __inp: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_neta(
        __net: in_addr_t,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __bits: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_nsap_addr(
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_uchar,
        __len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn inet_nsap_ntoa(
        __len: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_uchar,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    assert_eq!(
        ::std::mem::size_of::<rpcent>(),
        24usize,
        concat!("Size of: ", stringify!(rpcent))
    );
    assert_eq!(
        ::std::mem::align_of::<rpcent>(),
        8usize,
        concat!("Alignment of ", stringify!(rpcent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_number as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_number)
        )
    );
}
extern "C" {
    pub fn setrpcent(__stayopen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn getrpcbyname(__name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(__number: ::std::os::raw::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut rpcent,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrpcbynumber_r(
        __number: ::std::os::raw::c_int,
        __result_buf: *mut rpcent,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrpcent_r(
        __result_buf: *mut rpcent,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_addrtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_net as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_net)
        )
    );
}
extern "C" {
    pub fn __h_errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn herror(__str: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(__err_num: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addrtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addr_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
extern "C" {
    pub fn sethostent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr(
        __addr: *const ::std::os::raw::c_void,
        __len: __socklen_t,
        __type: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(__name: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname2(
        __name: *const ::std::os::raw::c_char,
        __af: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostent_r(
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyaddr_r(
        __addr: *const ::std::os::raw::c_void,
        __len: __socklen_t,
        __type: ::std::os::raw::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname2_r(
        __name: *const ::std::os::raw::c_char,
        __af: ::std::os::raw::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setnetent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getnetbyaddr(__net: u32, __type: ::std::os::raw::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(__name: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent_r(
        __result_buf: *mut netent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyaddr_r(
        __net: u32,
        __type: ::std::os::raw::c_int,
        __result_buf: *mut netent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut netent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_port as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_proto as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_proto)
        )
    );
}
extern "C" {
    pub fn setservent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn getservbyname(
        __name: *const ::std::os::raw::c_char,
        __proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        __port: ::std::os::raw::c_int,
        __proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent_r(
        __result_buf: *mut servent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyname_r(
        __name: *const ::std::os::raw::c_char,
        __proto: *const ::std::os::raw::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyport_r(
        __port: ::std::os::raw::c_int,
        __proto: *const ::std::os::raw::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_proto as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_proto)
        )
    );
}
extern "C" {
    pub fn setprotoent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getprotobyname(__name: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(__proto: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent_r(
        __result_buf: *mut protoent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprotobyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut protoent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprotobynumber_r(
        __proto: ::std::os::raw::c_int,
        __result_buf: *mut protoent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setnetgrent(__netgroup: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn getnetgrent(
        __hostp: *mut *mut ::std::os::raw::c_char,
        __userp: *mut *mut ::std::os::raw::c_char,
        __domainp: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn innetgr(
        __netgroup: *const ::std::os::raw::c_char,
        __host: *const ::std::os::raw::c_char,
        __user: *const ::std::os::raw::c_char,
        __domain: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetgrent_r(
        __hostp: *mut *mut ::std::os::raw::c_char,
        __userp: *mut *mut ::std::os::raw::c_char,
        __domainp: *mut *mut ::std::os::raw::c_char,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_ushort,
        __locuser: *const ::std::os::raw::c_char,
        __remuser: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_ushort,
        __locuser: *const ::std::os::raw::c_char,
        __remuser: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rexec(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __pass: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rexec_af(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __pass: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        __rhost: *const ::std::os::raw::c_char,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok_af(
        __rhost: *const ::std::os::raw::c_char,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(
        __raddr: u32,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_af(
        __raddr: *const ::std::os::raw::c_void,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(__alport: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(
        __alport: *mut ::std::os::raw::c_int,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_socktype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_canonname as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
extern "C" {
    pub fn getaddrinfo(
        __name: *const ::std::os::raw::c_char,
        __service: *const ::std::os::raw::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeaddrinfo(__ai: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(__ecode: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn getnameinfo(
        __sa: *const sockaddr,
        __salen: socklen_t,
        __host: *mut ::std::os::raw::c_char,
        __hostlen: socklen_t,
        __serv: *mut ::std::os::raw::c_char,
        __servlen: socklen_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type cc_t = ::std::os::raw::c_uchar;
pub type speed_t = ::std::os::raw::c_uint;
pub type tcflag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 32usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(
        ::std::mem::size_of::<termios>(),
        60usize,
        concat!("Size of: ", stringify!(termios))
    );
    assert_eq!(
        ::std::mem::align_of::<termios>(),
        4usize,
        concat!("Alignment of ", stringify!(termios))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_iflag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_iflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_oflag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_oflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cflag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_lflag as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_lflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cc as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ispeed as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ispeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ospeed as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ospeed)
        )
    );
}
extern "C" {
    pub fn cfgetospeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfgetispeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfsetospeed(__termios_p: *mut termios, __speed: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetispeed(__termios_p: *mut termios, __speed: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetspeed(__termios_p: *mut termios, __speed: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetattr(
        __fd: ::std::os::raw::c_int,
        __termios_p: *mut termios,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcsetattr(
        __fd: ::std::os::raw::c_int,
        __optional_actions: ::std::os::raw::c_int,
        __termios_p: *const termios,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfmakeraw(__termios_p: *mut termios);
}
extern "C" {
    pub fn tcsendbreak(
        __fd: ::std::os::raw::c_int,
        __duration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcdrain(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflush(
        __fd: ::std::os::raw::c_int,
        __queue_selector: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflow(
        __fd: ::std::os::raw::c_int,
        __action: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetsid(__fd: ::std::os::raw::c_int) -> __pid_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct passwd {
    pub pw_name: *mut ::std::os::raw::c_char,
    pub pw_passwd: *mut ::std::os::raw::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut ::std::os::raw::c_char,
    pub pw_dir: *mut ::std::os::raw::c_char,
    pub pw_shell: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_passwd() {
    assert_eq!(
        ::std::mem::size_of::<passwd>(),
        48usize,
        concat!("Size of: ", stringify!(passwd))
    );
    assert_eq!(
        ::std::mem::align_of::<passwd>(),
        8usize,
        concat!("Alignment of ", stringify!(passwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_passwd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_passwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_gid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_gecos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_gecos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_dir as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_shell as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_shell)
        )
    );
}
extern "C" {
    pub fn setpwent();
}
extern "C" {
    pub fn endpwent();
}
extern "C" {
    pub fn getpwent() -> *mut passwd;
}
extern "C" {
    pub fn fgetpwent(__stream: *mut FILE) -> *mut passwd;
}
extern "C" {
    pub fn putpwent(__p: *const passwd, __f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpwuid(__uid: __uid_t) -> *mut passwd;
}
extern "C" {
    pub fn getpwnam(__name: *const ::std::os::raw::c_char) -> *mut passwd;
}
extern "C" {
    pub fn getpwent_r(
        __resultbuf: *mut passwd,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpwuid_r(
        __uid: __uid_t,
        __resultbuf: *mut passwd,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpwnam_r(
        __name: *const ::std::os::raw::c_char,
        __resultbuf: *mut passwd,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpwent_r(
        __stream: *mut FILE,
        __resultbuf: *mut passwd,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_sem_t() {
    assert_eq!(
        ::std::mem::size_of::<sem_t>(),
        32usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sem_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: ::std::os::raw::c_int,
        __value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_destroy(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_open(
        __name: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn sem_close(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_wait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_trywait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_post(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_getvalue(
        __sem: *mut sem_t,
        __sval: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_tid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_overrun as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_status as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_utime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_stime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._lower as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._upper as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))
                ._addr_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_lsb
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()))._bounds as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_bounds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_fd as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._call_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigchld as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigfault as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigpoll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).__pad0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>()))._sifields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
pub const SI_ASYNCNL: _bindgen_ty_11 = -60;
pub const SI_DETHREAD: _bindgen_ty_11 = -7;
pub const SI_TKILL: _bindgen_ty_11 = -6;
pub const SI_SIGIO: _bindgen_ty_11 = -5;
pub const SI_ASYNCIO: _bindgen_ty_11 = -4;
pub const SI_MESGQ: _bindgen_ty_11 = -3;
pub const SI_TIMER: _bindgen_ty_11 = -2;
pub const SI_QUEUE: _bindgen_ty_11 = -1;
pub const SI_USER: _bindgen_ty_11 = 0;
pub const SI_KERNEL: _bindgen_ty_11 = 128;
pub type _bindgen_ty_11 = i32;
pub const ILL_ILLOPC: _bindgen_ty_12 = 1;
pub const ILL_ILLOPN: _bindgen_ty_12 = 2;
pub const ILL_ILLADR: _bindgen_ty_12 = 3;
pub const ILL_ILLTRP: _bindgen_ty_12 = 4;
pub const ILL_PRVOPC: _bindgen_ty_12 = 5;
pub const ILL_PRVREG: _bindgen_ty_12 = 6;
pub const ILL_COPROC: _bindgen_ty_12 = 7;
pub const ILL_BADSTK: _bindgen_ty_12 = 8;
pub const ILL_BADIADDR: _bindgen_ty_12 = 9;
pub type _bindgen_ty_12 = u32;
pub const FPE_INTDIV: _bindgen_ty_13 = 1;
pub const FPE_INTOVF: _bindgen_ty_13 = 2;
pub const FPE_FLTDIV: _bindgen_ty_13 = 3;
pub const FPE_FLTOVF: _bindgen_ty_13 = 4;
pub const FPE_FLTUND: _bindgen_ty_13 = 5;
pub const FPE_FLTRES: _bindgen_ty_13 = 6;
pub const FPE_FLTINV: _bindgen_ty_13 = 7;
pub const FPE_FLTSUB: _bindgen_ty_13 = 8;
pub const FPE_FLTUNK: _bindgen_ty_13 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_13 = 15;
pub type _bindgen_ty_13 = u32;
pub const SEGV_MAPERR: _bindgen_ty_14 = 1;
pub const SEGV_ACCERR: _bindgen_ty_14 = 2;
pub const SEGV_BNDERR: _bindgen_ty_14 = 3;
pub const SEGV_PKUERR: _bindgen_ty_14 = 4;
pub const SEGV_ACCADI: _bindgen_ty_14 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_14 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_14 = 7;
pub type _bindgen_ty_14 = u32;
pub const BUS_ADRALN: _bindgen_ty_15 = 1;
pub const BUS_ADRERR: _bindgen_ty_15 = 2;
pub const BUS_OBJERR: _bindgen_ty_15 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_15 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_15 = 5;
pub type _bindgen_ty_15 = u32;
pub const CLD_EXITED: _bindgen_ty_16 = 1;
pub const CLD_KILLED: _bindgen_ty_16 = 2;
pub const CLD_DUMPED: _bindgen_ty_16 = 3;
pub const CLD_TRAPPED: _bindgen_ty_16 = 4;
pub const CLD_STOPPED: _bindgen_ty_16 = 5;
pub const CLD_CONTINUED: _bindgen_ty_16 = 6;
pub type _bindgen_ty_16 = u32;
pub const POLL_IN: _bindgen_ty_17 = 1;
pub const POLL_OUT: _bindgen_ty_17 = 2;
pub const POLL_MSG: _bindgen_ty_17 = 3;
pub const POLL_ERR: _bindgen_ty_17 = 4;
pub const POLL_PRI: _bindgen_ty_17 = 5;
pub const POLL_HUP: _bindgen_ty_17 = 6;
pub type _bindgen_ty_17 = u32;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_18 = 0;
pub const SIGEV_NONE: _bindgen_ty_18 = 1;
pub const SIGEV_THREAD: _bindgen_ty_18 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_18 = 4;
pub type _bindgen_ty_18 = u32;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).__glibc_reserved1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).__glibc_reserved1 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).fpstate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).__fpstate_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdi as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rcx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).eflags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__pad0 as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(
        ::std::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).xstate_bv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).__glibc_reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).__glibc_reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_stack_t() {
    assert_eq!(
        ::std::mem::size_of::<stack_t>(),
        24usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).__glibc_reserved1 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).gregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).fpregs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    assert_eq!(
        ::std::mem::size_of::<ucontext_t>(),
        968usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_mcontext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_sigmask as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).__fpregs_mem as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__fpregs_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).__ssp as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__ssp)
        )
    );
}
extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_19 = 1;
pub const SS_DISABLE: _bindgen_ty_19 = 2;
pub type _bindgen_ty_19 = u32;
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_20 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = u32;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_21 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_21 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_21 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_21 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_21 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_21 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_21 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_21 = 0;
pub type _bindgen_ty_21 = u32;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_22 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_22 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_22 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_22 = 1;
pub type _bindgen_ty_22 = u32;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_23 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_23 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_23 = 2;
pub type _bindgen_ty_23 = u32;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_24 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_24 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_24 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_24 = 0;
pub type _bindgen_ty_24 = u32;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_25 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_25 = 1;
pub type _bindgen_ty_25 = u32;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_26 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_26 = 1;
pub type _bindgen_ty_26 = u32;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_27 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_27 = 1;
pub type _bindgen_ty_27 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_28 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_28 = 1;
pub type _bindgen_ty_28 = u32;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_29 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_29 = 1;
pub type _bindgen_ty_29 = u32;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv__work {
    pub work: ::std::option::Option<unsafe extern "C" fn(w: *mut uv__work)>,
    pub done: ::std::option::Option<
        unsafe extern "C" fn(w: *mut uv__work, status: ::std::os::raw::c_int),
    >,
    pub loop_: *mut uv_loop_s,
    pub wq: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_uv__work() {
    assert_eq!(
        ::std::mem::size_of::<uv__work>(),
        40usize,
        concat!("Size of: ", stringify!(uv__work))
    );
    assert_eq!(
        ::std::mem::align_of::<uv__work>(),
        8usize,
        concat!("Alignment of ", stringify!(uv__work))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__work>())).done as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__work),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__work>())).loop_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__work),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__work>())).wq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__work),
            "::",
            stringify!(wq)
        )
    );
}
pub type uv__io_cb = ::std::option::Option<
    unsafe extern "C" fn(loop_: *mut uv_loop_s, w: *mut uv__io_s, events: ::std::os::raw::c_uint),
>;
pub type uv__io_t = uv__io_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv__io_s {
    pub cb: uv__io_cb,
    pub pending_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watcher_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub pevents: ::std::os::raw::c_uint,
    pub events: ::std::os::raw::c_uint,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv__io_s() {
    assert_eq!(
        ::std::mem::size_of::<uv__io_s>(),
        56usize,
        concat!("Size of: ", stringify!(uv__io_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv__io_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv__io_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).pending_queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(pending_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).watcher_queue as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(watcher_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).pevents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(pevents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).events as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).fd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_buf_t {
    pub base: *mut ::std::os::raw::c_char,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_uv_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_buf_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_buf_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_buf_t>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_buf_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_buf_t>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_buf_t),
            "::",
            stringify!(len)
        )
    );
}
pub type uv_os_sock_t = ::std::os::raw::c_int;
pub type uv_os_fd_t = ::std::os::raw::c_int;
pub type uv_pid_t = pid_t;
pub type uv_once_t = pthread_once_t;
pub type uv_thread_t = pthread_t;
pub type uv_mutex_t = pthread_mutex_t;
pub type uv_rwlock_t = pthread_rwlock_t;
pub type uv_sem_t = sem_t;
pub type uv_cond_t = pthread_cond_t;
pub type uv_key_t = pthread_key_t;
pub type uv_barrier_t = pthread_barrier_t;
pub type uv_gid_t = gid_t;
pub type uv_uid_t = uid_t;
pub type uv__dirent_t = dirent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_lib_t {
    pub handle: *mut ::std::os::raw::c_void,
    pub errmsg: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uv_lib_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_lib_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_lib_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_lib_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_lib_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_lib_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_lib_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_lib_t>())).errmsg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_lib_t),
            "::",
            stringify!(errmsg)
        )
    );
}
pub const uv_errno_t_UV_E2BIG: uv_errno_t = -7;
pub const uv_errno_t_UV_EACCES: uv_errno_t = -13;
pub const uv_errno_t_UV_EADDRINUSE: uv_errno_t = -98;
pub const uv_errno_t_UV_EADDRNOTAVAIL: uv_errno_t = -99;
pub const uv_errno_t_UV_EAFNOSUPPORT: uv_errno_t = -97;
pub const uv_errno_t_UV_EAGAIN: uv_errno_t = -11;
pub const uv_errno_t_UV_EAI_ADDRFAMILY: uv_errno_t = -3000;
pub const uv_errno_t_UV_EAI_AGAIN: uv_errno_t = -3001;
pub const uv_errno_t_UV_EAI_BADFLAGS: uv_errno_t = -3002;
pub const uv_errno_t_UV_EAI_BADHINTS: uv_errno_t = -3013;
pub const uv_errno_t_UV_EAI_CANCELED: uv_errno_t = -3003;
pub const uv_errno_t_UV_EAI_FAIL: uv_errno_t = -3004;
pub const uv_errno_t_UV_EAI_FAMILY: uv_errno_t = -3005;
pub const uv_errno_t_UV_EAI_MEMORY: uv_errno_t = -3006;
pub const uv_errno_t_UV_EAI_NODATA: uv_errno_t = -3007;
pub const uv_errno_t_UV_EAI_NONAME: uv_errno_t = -3008;
pub const uv_errno_t_UV_EAI_OVERFLOW: uv_errno_t = -3009;
pub const uv_errno_t_UV_EAI_PROTOCOL: uv_errno_t = -3014;
pub const uv_errno_t_UV_EAI_SERVICE: uv_errno_t = -3010;
pub const uv_errno_t_UV_EAI_SOCKTYPE: uv_errno_t = -3011;
pub const uv_errno_t_UV_EALREADY: uv_errno_t = -114;
pub const uv_errno_t_UV_EBADF: uv_errno_t = -9;
pub const uv_errno_t_UV_EBUSY: uv_errno_t = -16;
pub const uv_errno_t_UV_ECANCELED: uv_errno_t = -125;
pub const uv_errno_t_UV_ECHARSET: uv_errno_t = -4080;
pub const uv_errno_t_UV_ECONNABORTED: uv_errno_t = -103;
pub const uv_errno_t_UV_ECONNREFUSED: uv_errno_t = -111;
pub const uv_errno_t_UV_ECONNRESET: uv_errno_t = -104;
pub const uv_errno_t_UV_EDESTADDRREQ: uv_errno_t = -89;
pub const uv_errno_t_UV_EEXIST: uv_errno_t = -17;
pub const uv_errno_t_UV_EFAULT: uv_errno_t = -14;
pub const uv_errno_t_UV_EFBIG: uv_errno_t = -27;
pub const uv_errno_t_UV_EHOSTUNREACH: uv_errno_t = -113;
pub const uv_errno_t_UV_EINTR: uv_errno_t = -4;
pub const uv_errno_t_UV_EINVAL: uv_errno_t = -22;
pub const uv_errno_t_UV_EIO: uv_errno_t = -5;
pub const uv_errno_t_UV_EISCONN: uv_errno_t = -106;
pub const uv_errno_t_UV_EISDIR: uv_errno_t = -21;
pub const uv_errno_t_UV_ELOOP: uv_errno_t = -40;
pub const uv_errno_t_UV_EMFILE: uv_errno_t = -24;
pub const uv_errno_t_UV_EMSGSIZE: uv_errno_t = -90;
pub const uv_errno_t_UV_ENAMETOOLONG: uv_errno_t = -36;
pub const uv_errno_t_UV_ENETDOWN: uv_errno_t = -100;
pub const uv_errno_t_UV_ENETUNREACH: uv_errno_t = -101;
pub const uv_errno_t_UV_ENFILE: uv_errno_t = -23;
pub const uv_errno_t_UV_ENOBUFS: uv_errno_t = -105;
pub const uv_errno_t_UV_ENODEV: uv_errno_t = -19;
pub const uv_errno_t_UV_ENOENT: uv_errno_t = -2;
pub const uv_errno_t_UV_ENOMEM: uv_errno_t = -12;
pub const uv_errno_t_UV_ENONET: uv_errno_t = -64;
pub const uv_errno_t_UV_ENOPROTOOPT: uv_errno_t = -92;
pub const uv_errno_t_UV_ENOSPC: uv_errno_t = -28;
pub const uv_errno_t_UV_ENOSYS: uv_errno_t = -38;
pub const uv_errno_t_UV_ENOTCONN: uv_errno_t = -107;
pub const uv_errno_t_UV_ENOTDIR: uv_errno_t = -20;
pub const uv_errno_t_UV_ENOTEMPTY: uv_errno_t = -39;
pub const uv_errno_t_UV_ENOTSOCK: uv_errno_t = -88;
pub const uv_errno_t_UV_ENOTSUP: uv_errno_t = -95;
pub const uv_errno_t_UV_EPERM: uv_errno_t = -1;
pub const uv_errno_t_UV_EPIPE: uv_errno_t = -32;
pub const uv_errno_t_UV_EPROTO: uv_errno_t = -71;
pub const uv_errno_t_UV_EPROTONOSUPPORT: uv_errno_t = -93;
pub const uv_errno_t_UV_EPROTOTYPE: uv_errno_t = -91;
pub const uv_errno_t_UV_ERANGE: uv_errno_t = -34;
pub const uv_errno_t_UV_EROFS: uv_errno_t = -30;
pub const uv_errno_t_UV_ESHUTDOWN: uv_errno_t = -108;
pub const uv_errno_t_UV_ESPIPE: uv_errno_t = -29;
pub const uv_errno_t_UV_ESRCH: uv_errno_t = -3;
pub const uv_errno_t_UV_ETIMEDOUT: uv_errno_t = -110;
pub const uv_errno_t_UV_ETXTBSY: uv_errno_t = -26;
pub const uv_errno_t_UV_EXDEV: uv_errno_t = -18;
pub const uv_errno_t_UV_UNKNOWN: uv_errno_t = -4094;
pub const uv_errno_t_UV_EOF: uv_errno_t = -4095;
pub const uv_errno_t_UV_ENXIO: uv_errno_t = -6;
pub const uv_errno_t_UV_EMLINK: uv_errno_t = -31;
pub const uv_errno_t_UV_EHOSTDOWN: uv_errno_t = -112;
pub const uv_errno_t_UV_EREMOTEIO: uv_errno_t = -121;
pub const uv_errno_t_UV_ENOTTY: uv_errno_t = -25;
pub const uv_errno_t_UV_EFTYPE: uv_errno_t = -4028;
pub const uv_errno_t_UV_ERRNO_MAX: uv_errno_t = -4096;
pub type uv_errno_t = i32;
pub const uv_handle_type_UV_UNKNOWN_HANDLE: uv_handle_type = 0;
pub const uv_handle_type_UV_ASYNC: uv_handle_type = 1;
pub const uv_handle_type_UV_CHECK: uv_handle_type = 2;
pub const uv_handle_type_UV_FS_EVENT: uv_handle_type = 3;
pub const uv_handle_type_UV_FS_POLL: uv_handle_type = 4;
pub const uv_handle_type_UV_HANDLE: uv_handle_type = 5;
pub const uv_handle_type_UV_IDLE: uv_handle_type = 6;
pub const uv_handle_type_UV_NAMED_PIPE: uv_handle_type = 7;
pub const uv_handle_type_UV_POLL: uv_handle_type = 8;
pub const uv_handle_type_UV_PREPARE: uv_handle_type = 9;
pub const uv_handle_type_UV_PROCESS: uv_handle_type = 10;
pub const uv_handle_type_UV_STREAM: uv_handle_type = 11;
pub const uv_handle_type_UV_TCP: uv_handle_type = 12;
pub const uv_handle_type_UV_TIMER: uv_handle_type = 13;
pub const uv_handle_type_UV_TTY: uv_handle_type = 14;
pub const uv_handle_type_UV_UDP: uv_handle_type = 15;
pub const uv_handle_type_UV_SIGNAL: uv_handle_type = 16;
pub const uv_handle_type_UV_FILE: uv_handle_type = 17;
pub const uv_handle_type_UV_HANDLE_TYPE_MAX: uv_handle_type = 18;
pub type uv_handle_type = u32;
pub const uv_req_type_UV_UNKNOWN_REQ: uv_req_type = 0;
pub const uv_req_type_UV_REQ: uv_req_type = 1;
pub const uv_req_type_UV_CONNECT: uv_req_type = 2;
pub const uv_req_type_UV_WRITE: uv_req_type = 3;
pub const uv_req_type_UV_SHUTDOWN: uv_req_type = 4;
pub const uv_req_type_UV_UDP_SEND: uv_req_type = 5;
pub const uv_req_type_UV_FS: uv_req_type = 6;
pub const uv_req_type_UV_WORK: uv_req_type = 7;
pub const uv_req_type_UV_GETADDRINFO: uv_req_type = 8;
pub const uv_req_type_UV_GETNAMEINFO: uv_req_type = 9;
pub const uv_req_type_UV_REQ_TYPE_MAX: uv_req_type = 10;
pub type uv_req_type = u32;
pub type uv_loop_t = uv_loop_s;
pub type uv_handle_t = uv_handle_s;
pub type uv_dir_t = uv_dir_s;
pub type uv_stream_t = uv_stream_s;
pub type uv_tcp_t = uv_tcp_s;
pub type uv_udp_t = uv_udp_s;
pub type uv_pipe_t = uv_pipe_s;
pub type uv_tty_t = uv_tty_s;
pub type uv_poll_t = uv_poll_s;
pub type uv_timer_t = uv_timer_s;
pub type uv_prepare_t = uv_prepare_s;
pub type uv_check_t = uv_check_s;
pub type uv_idle_t = uv_idle_s;
pub type uv_async_t = uv_async_s;
pub type uv_process_t = uv_process_s;
pub type uv_fs_event_t = uv_fs_event_s;
pub type uv_fs_poll_t = uv_fs_poll_s;
pub type uv_signal_t = uv_signal_s;
pub type uv_req_t = uv_req_s;
pub type uv_getaddrinfo_t = uv_getaddrinfo_s;
pub type uv_getnameinfo_t = uv_getnameinfo_s;
pub type uv_shutdown_t = uv_shutdown_s;
pub type uv_write_t = uv_write_s;
pub type uv_connect_t = uv_connect_s;
pub type uv_udp_send_t = uv_udp_send_s;
pub type uv_fs_t = uv_fs_s;
pub type uv_work_t = uv_work_s;
pub type uv_cpu_info_t = uv_cpu_info_s;
pub type uv_interface_address_t = uv_interface_address_s;
pub type uv_dirent_t = uv_dirent_s;
pub type uv_passwd_t = uv_passwd_s;
pub type uv_utsname_t = uv_utsname_s;
pub const uv_loop_option_UV_LOOP_BLOCK_SIGNAL: uv_loop_option = 0;
pub type uv_loop_option = u32;
pub const uv_run_mode_UV_RUN_DEFAULT: uv_run_mode = 0;
pub const uv_run_mode_UV_RUN_ONCE: uv_run_mode = 1;
pub const uv_run_mode_UV_RUN_NOWAIT: uv_run_mode = 2;
pub type uv_run_mode = u32;
extern "C" {
    pub fn uv_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn uv_version_string() -> *const ::std::os::raw::c_char;
}
pub type uv_malloc_func =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
pub type uv_realloc_func = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type uv_calloc_func = ::std::option::Option<
    unsafe extern "C" fn(count: usize, size: usize) -> *mut ::std::os::raw::c_void,
>;
pub type uv_free_func =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn uv_replace_allocator(
        malloc_func: uv_malloc_func,
        realloc_func: uv_realloc_func,
        calloc_func: uv_calloc_func,
        free_func: uv_free_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_default_loop() -> *mut uv_loop_t;
}
extern "C" {
    pub fn uv_loop_init(loop_: *mut uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_loop_close(loop_: *mut uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_loop_new() -> *mut uv_loop_t;
}
extern "C" {
    pub fn uv_loop_delete(arg1: *mut uv_loop_t);
}
extern "C" {
    pub fn uv_loop_size() -> usize;
}
extern "C" {
    pub fn uv_loop_alive(loop_: *const uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_loop_configure(
        loop_: *mut uv_loop_t,
        option: uv_loop_option,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_run(arg1: *mut uv_loop_t, mode: uv_run_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_stop(arg1: *mut uv_loop_t);
}
extern "C" {
    pub fn uv_ref(arg1: *mut uv_handle_t);
}
extern "C" {
    pub fn uv_unref(arg1: *mut uv_handle_t);
}
extern "C" {
    pub fn uv_has_ref(arg1: *const uv_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_update_time(arg1: *mut uv_loop_t);
}
extern "C" {
    pub fn uv_now(arg1: *const uv_loop_t) -> u64;
}
extern "C" {
    pub fn uv_backend_fd(arg1: *const uv_loop_t) -> uv_os_fd_t;
}
extern "C" {
    pub fn uv_backend_timeout(arg1: *const uv_loop_t) -> ::std::os::raw::c_int;
}
pub type uv_alloc_cb = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut uv_handle_t, suggested_size: usize, buf: *mut uv_buf_t),
>;
pub type uv_read_cb = ::std::option::Option<
    unsafe extern "C" fn(stream: *mut uv_stream_t, nread: isize, buf: *const uv_buf_t),
>;
pub type uv_write_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_write_t, status: ::std::os::raw::c_int),
>;
pub type uv_connect_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_connect_t, status: ::std::os::raw::c_int),
>;
pub type uv_shutdown_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_shutdown_t, status: ::std::os::raw::c_int),
>;
pub type uv_connection_cb = ::std::option::Option<
    unsafe extern "C" fn(server: *mut uv_stream_t, status: ::std::os::raw::c_int),
>;
pub type uv_close_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_handle_t)>;
pub type uv_poll_cb = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut uv_poll_t,
        status: ::std::os::raw::c_int,
        events: ::std::os::raw::c_int,
    ),
>;
pub type uv_timer_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_timer_t)>;
pub type uv_async_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_async_t)>;
pub type uv_prepare_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_prepare_t)>;
pub type uv_check_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_check_t)>;
pub type uv_idle_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_idle_t)>;
pub type uv_exit_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut uv_process_t,
        exit_status: i64,
        term_signal: ::std::os::raw::c_int,
    ),
>;
pub type uv_walk_cb = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut uv_handle_t, arg: *mut ::std::os::raw::c_void),
>;
pub type uv_fs_cb = ::std::option::Option<unsafe extern "C" fn(req: *mut uv_fs_t)>;
pub type uv_work_cb = ::std::option::Option<unsafe extern "C" fn(req: *mut uv_work_t)>;
pub type uv_after_work_cb =
    ::std::option::Option<unsafe extern "C" fn(req: *mut uv_work_t, status: ::std::os::raw::c_int)>;
pub type uv_getaddrinfo_cb = ::std::option::Option<
    unsafe extern "C" fn(
        req: *mut uv_getaddrinfo_t,
        status: ::std::os::raw::c_int,
        res: *mut addrinfo,
    ),
>;
pub type uv_getnameinfo_cb = ::std::option::Option<
    unsafe extern "C" fn(
        req: *mut uv_getnameinfo_t,
        status: ::std::os::raw::c_int,
        hostname: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_timespec_t {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_uv_timespec_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_timespec_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_timespec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_timespec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_timespec_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timespec_t>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timespec_t),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timespec_t>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timespec_t),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_stat_t {
    pub st_dev: u64,
    pub st_mode: u64,
    pub st_nlink: u64,
    pub st_uid: u64,
    pub st_gid: u64,
    pub st_rdev: u64,
    pub st_ino: u64,
    pub st_size: u64,
    pub st_blksize: u64,
    pub st_blocks: u64,
    pub st_flags: u64,
    pub st_gen: u64,
    pub st_atim: uv_timespec_t,
    pub st_mtim: uv_timespec_t,
    pub st_ctim: uv_timespec_t,
    pub st_birthtim: uv_timespec_t,
}
#[test]
fn bindgen_test_layout_uv_stat_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_stat_t>(),
        160usize,
        concat!("Size of: ", stringify!(uv_stat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_stat_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_uid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_ino as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_blksize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_blocks as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_gen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_atim as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_mtim as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_ctim as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_birthtim as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_birthtim)
        )
    );
}
pub type uv_fs_event_cb = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut uv_fs_event_t,
        filename: *const ::std::os::raw::c_char,
        events: ::std::os::raw::c_int,
        status: ::std::os::raw::c_int,
    ),
>;
pub type uv_fs_poll_cb = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut uv_fs_poll_t,
        status: ::std::os::raw::c_int,
        prev: *const uv_stat_t,
        curr: *const uv_stat_t,
    ),
>;
pub type uv_signal_cb = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut uv_signal_t, signum: ::std::os::raw::c_int),
>;
pub const uv_membership_UV_LEAVE_GROUP: uv_membership = 0;
pub const uv_membership_UV_JOIN_GROUP: uv_membership = 1;
pub type uv_membership = u32;
extern "C" {
    pub fn uv_translate_sys_error(sys_errno: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uv_strerror_r(
        err: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn uv_err_name(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uv_err_name_r(
        err: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_req_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub reserved: [*mut ::std::os::raw::c_void; 6usize],
}
#[test]
fn bindgen_test_layout_uv_req_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_req_s>(),
        64usize,
        concat!("Size of: ", stringify!(uv_req_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_req_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_req_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_req_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_req_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_req_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_req_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_req_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_req_s),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn uv_shutdown(
        req: *mut uv_shutdown_t,
        handle: *mut uv_stream_t,
        cb: uv_shutdown_cb,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_shutdown_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub reserved: [*mut ::std::os::raw::c_void; 6usize],
    pub handle: *mut uv_stream_t,
    pub cb: uv_shutdown_cb,
}
#[test]
fn bindgen_test_layout_uv_shutdown_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_shutdown_s>(),
        80usize,
        concat!("Size of: ", stringify!(uv_shutdown_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_shutdown_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_shutdown_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).handle as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(cb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_handle_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uv_handle_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_handle_s>(),
        64usize,
        concat!("Size of: ", stringify!(uv_handle_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_handle_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_handle_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn uv_handle_size(type_: uv_handle_type) -> usize;
}
extern "C" {
    pub fn uv_handle_get_type(handle: *const uv_handle_t) -> uv_handle_type;
}
extern "C" {
    pub fn uv_handle_type_name(type_: uv_handle_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uv_handle_get_data(handle: *const uv_handle_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn uv_handle_get_loop(handle: *const uv_handle_t) -> *mut uv_loop_t;
}
extern "C" {
    pub fn uv_handle_set_data(handle: *mut uv_handle_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uv_req_size(type_: uv_req_type) -> usize;
}
extern "C" {
    pub fn uv_req_get_data(req: *const uv_req_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn uv_req_set_data(req: *mut uv_req_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uv_req_get_type(req: *const uv_req_t) -> uv_req_type;
}
extern "C" {
    pub fn uv_req_type_name(type_: uv_req_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uv_is_active(handle: *const uv_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_walk(loop_: *mut uv_loop_t, walk_cb: uv_walk_cb, arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uv_print_all_handles(loop_: *mut uv_loop_t, stream: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uv_print_active_handles(loop_: *mut uv_loop_t, stream: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uv_close(handle: *mut uv_handle_t, close_cb: uv_close_cb);
}
extern "C" {
    pub fn uv_send_buffer_size(
        handle: *mut uv_handle_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_recv_buffer_size(
        handle: *mut uv_handle_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fileno(handle: *const uv_handle_t, fd: *mut uv_os_fd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_buf_init(base: *mut ::std::os::raw::c_char, len: usize) -> uv_buf_t;
}
extern "C" {
    pub fn uv_pipe(
        fds: *mut uv_os_fd_t,
        read_flags: ::std::os::raw::c_int,
        write_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_socketpair(
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        socket_vector: *mut uv_os_sock_t,
        flags0: ::std::os::raw::c_int,
        flags1: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_stream_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_uv_stream_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_stream_s>(),
        216usize,
        concat!("Size of: ", stringify!(uv_stream_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stream_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_stream_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).write_queue_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).alloc_cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).read_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).connect_req as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).shutdown_req as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).io_watcher as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).write_queue as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_stream_s>())).write_completed_queue as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).connection_cb as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).delayed_error as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).accepted_fd as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).queued_fds as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(queued_fds)
        )
    );
}
extern "C" {
    pub fn uv_stream_get_write_queue_size(stream: *const uv_stream_t) -> usize;
}
extern "C" {
    pub fn uv_listen(
        stream: *mut uv_stream_t,
        backlog: ::std::os::raw::c_int,
        cb: uv_connection_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_accept(server: *mut uv_stream_t, client: *mut uv_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_read_start(
        arg1: *mut uv_stream_t,
        alloc_cb: uv_alloc_cb,
        read_cb: uv_read_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_read_stop(arg1: *mut uv_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_write(
        req: *mut uv_write_t,
        handle: *mut uv_stream_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        cb: uv_write_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_write2(
        req: *mut uv_write_t,
        handle: *mut uv_stream_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        send_handle: *mut uv_stream_t,
        cb: uv_write_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_try_write(
        handle: *mut uv_stream_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_write_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub reserved: [*mut ::std::os::raw::c_void; 6usize],
    pub cb: uv_write_cb,
    pub send_handle: *mut uv_stream_t,
    pub handle: *mut uv_stream_t,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_index: ::std::os::raw::c_uint,
    pub bufs: *mut uv_buf_t,
    pub nbufs: ::std::os::raw::c_uint,
    pub error: ::std::os::raw::c_int,
    pub bufsml: [uv_buf_t; 4usize],
}
#[test]
fn bindgen_test_layout_uv_write_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_write_s>(),
        192usize,
        concat!("Size of: ", stringify!(uv_write_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_write_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_write_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).send_handle as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(send_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).handle as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).queue as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).write_index as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(write_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).bufs as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).nbufs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(nbufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).error as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).bufsml as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(bufsml)
        )
    );
}
extern "C" {
    pub fn uv_is_readable(handle: *const uv_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_is_writable(handle: *const uv_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_stream_set_blocking(
        handle: *mut uv_stream_t,
        blocking: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_is_closing(handle: *const uv_handle_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_tcp_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_uv_tcp_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_tcp_s>(),
        216usize,
        concat!("Size of: ", stringify!(uv_tcp_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_tcp_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_tcp_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).write_queue_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).alloc_cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).read_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).connect_req as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).shutdown_req as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).io_watcher as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).write_queue as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).write_completed_queue as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).connection_cb as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).delayed_error as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).accepted_fd as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).queued_fds as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(queued_fds)
        )
    );
}
extern "C" {
    pub fn uv_tcp_init(arg1: *mut uv_loop_t, handle: *mut uv_tcp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tcp_init_ex(
        arg1: *mut uv_loop_t,
        handle: *mut uv_tcp_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tcp_open(handle: *mut uv_tcp_t, sock: uv_os_sock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tcp_nodelay(
        handle: *mut uv_tcp_t,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tcp_keepalive(
        handle: *mut uv_tcp_t,
        enable: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tcp_simultaneous_accepts(
        handle: *mut uv_tcp_t,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const uv_tcp_flags_UV_TCP_IPV6ONLY: uv_tcp_flags = 1;
pub type uv_tcp_flags = u32;
extern "C" {
    pub fn uv_tcp_bind(
        handle: *mut uv_tcp_t,
        addr: *const sockaddr,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tcp_getsockname(
        handle: *const uv_tcp_t,
        name: *mut sockaddr,
        namelen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tcp_getpeername(
        handle: *const uv_tcp_t,
        name: *mut sockaddr,
        namelen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tcp_connect(
        req: *mut uv_connect_t,
        handle: *mut uv_tcp_t,
        addr: *const sockaddr,
        cb: uv_connect_cb,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_connect_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub reserved: [*mut ::std::os::raw::c_void; 6usize],
    pub cb: uv_connect_cb,
    pub handle: *mut uv_stream_t,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_uv_connect_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_connect_s>(),
        96usize,
        concat!("Size of: ", stringify!(uv_connect_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_connect_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_connect_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).handle as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).queue as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(queue)
        )
    );
}
pub const uv_udp_flags_UV_UDP_IPV6ONLY: uv_udp_flags = 1;
pub const uv_udp_flags_UV_UDP_PARTIAL: uv_udp_flags = 2;
pub const uv_udp_flags_UV_UDP_REUSEADDR: uv_udp_flags = 4;
pub type uv_udp_flags = u32;
pub type uv_udp_send_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_udp_send_t, status: ::std::os::raw::c_int),
>;
pub type uv_udp_recv_cb = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut uv_udp_t,
        nread: isize,
        buf: *const uv_buf_t,
        addr: *const sockaddr,
        flags: ::std::os::raw::c_uint,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_udp_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub send_queue_size: usize,
    pub send_queue_count: usize,
    pub alloc_cb: uv_alloc_cb,
    pub recv_cb: uv_udp_recv_cb,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_uv_udp_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_udp_s>(),
        184usize,
        concat!("Size of: ", stringify!(uv_udp_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_udp_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_udp_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).send_queue_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(send_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).send_queue_count as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(send_queue_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).alloc_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).recv_cb as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(recv_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).io_watcher as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).write_queue as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).write_completed_queue as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_udp_send_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub reserved: [*mut ::std::os::raw::c_void; 6usize],
    pub handle: *mut uv_udp_t,
    pub cb: uv_udp_send_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub addr: sockaddr_storage,
    pub nbufs: ::std::os::raw::c_uint,
    pub bufs: *mut uv_buf_t,
    pub status: isize,
    pub send_cb: uv_udp_send_cb,
    pub bufsml: [uv_buf_t; 4usize],
}
#[test]
fn bindgen_test_layout_uv_udp_send_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_udp_send_s>(),
        320usize,
        concat!("Size of: ", stringify!(uv_udp_send_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_udp_send_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_udp_send_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).handle as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).queue as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).addr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).nbufs as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(nbufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).bufs as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).status as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).send_cb as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(send_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).bufsml as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(bufsml)
        )
    );
}
extern "C" {
    pub fn uv_udp_init(arg1: *mut uv_loop_t, handle: *mut uv_udp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_init_ex(
        arg1: *mut uv_loop_t,
        handle: *mut uv_udp_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_open(handle: *mut uv_udp_t, sock: uv_os_sock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_bind(
        handle: *mut uv_udp_t,
        addr: *const sockaddr,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_connect(handle: *mut uv_udp_t, addr: *const sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_getpeername(
        handle: *const uv_udp_t,
        name: *mut sockaddr,
        namelen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_getsockname(
        handle: *const uv_udp_t,
        name: *mut sockaddr,
        namelen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_set_membership(
        handle: *mut uv_udp_t,
        multicast_addr: *const ::std::os::raw::c_char,
        interface_addr: *const ::std::os::raw::c_char,
        membership: uv_membership,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_set_multicast_loop(
        handle: *mut uv_udp_t,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_set_multicast_ttl(
        handle: *mut uv_udp_t,
        ttl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_set_multicast_interface(
        handle: *mut uv_udp_t,
        interface_addr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_set_broadcast(
        handle: *mut uv_udp_t,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_set_ttl(
        handle: *mut uv_udp_t,
        ttl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_send(
        req: *mut uv_udp_send_t,
        handle: *mut uv_udp_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        addr: *const sockaddr,
        send_cb: uv_udp_send_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_try_send(
        handle: *mut uv_udp_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        addr: *const sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_recv_start(
        handle: *mut uv_udp_t,
        alloc_cb: uv_alloc_cb,
        recv_cb: uv_udp_recv_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_recv_stop(handle: *mut uv_udp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_udp_get_send_queue_size(handle: *const uv_udp_t) -> usize;
}
extern "C" {
    pub fn uv_udp_get_send_queue_count(handle: *const uv_udp_t) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_tty_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
    pub orig_termios: termios,
    pub mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_tty_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_tty_s>(),
        280usize,
        concat!("Size of: ", stringify!(uv_tty_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_tty_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_tty_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).write_queue_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).alloc_cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).read_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).connect_req as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).shutdown_req as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).io_watcher as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).write_queue as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).write_completed_queue as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).connection_cb as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).delayed_error as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).accepted_fd as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).queued_fds as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(queued_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).orig_termios as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(orig_termios)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).mode as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(mode)
        )
    );
}
pub const uv_tty_mode_t_UV_TTY_MODE_NORMAL: uv_tty_mode_t = 0;
pub const uv_tty_mode_t_UV_TTY_MODE_RAW: uv_tty_mode_t = 1;
pub const uv_tty_mode_t_UV_TTY_MODE_IO: uv_tty_mode_t = 2;
pub type uv_tty_mode_t = u32;
extern "C" {
    pub fn uv_tty_init(
        arg1: *mut uv_loop_t,
        arg2: *mut uv_tty_t,
        fd: uv_os_fd_t,
        readable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tty_set_mode(arg1: *mut uv_tty_t, mode: uv_tty_mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tty_reset_mode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_tty_get_winsize(
        arg1: *mut uv_tty_t,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_guess_handle(file: uv_os_fd_t) -> uv_handle_type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_pipe_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
    pub ipc: ::std::os::raw::c_int,
    pub pipe_fname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uv_pipe_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_pipe_s>(),
        232usize,
        concat!("Size of: ", stringify!(uv_pipe_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_pipe_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_pipe_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).write_queue_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).alloc_cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).read_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).connect_req as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).shutdown_req as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).io_watcher as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).write_queue as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).write_completed_queue as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).connection_cb as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).delayed_error as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).accepted_fd as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).queued_fds as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(queued_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).ipc as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(ipc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).pipe_fname as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(pipe_fname)
        )
    );
}
extern "C" {
    pub fn uv_pipe_init(
        arg1: *mut uv_loop_t,
        handle: *mut uv_pipe_t,
        ipc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_pipe_open(arg1: *mut uv_pipe_t, file: uv_os_fd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_pipe_bind(
        handle: *mut uv_pipe_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_pipe_connect(
        req: *mut uv_connect_t,
        handle: *mut uv_pipe_t,
        name: *const ::std::os::raw::c_char,
        cb: uv_connect_cb,
    );
}
extern "C" {
    pub fn uv_pipe_getsockname(
        handle: *const uv_pipe_t,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_pipe_getpeername(
        handle: *const uv_pipe_t,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_pipe_pending_instances(handle: *mut uv_pipe_t, count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn uv_pipe_pending_count(handle: *mut uv_pipe_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_pipe_pending_type(handle: *mut uv_pipe_t) -> uv_handle_type;
}
extern "C" {
    pub fn uv_pipe_chmod(
        handle: *mut uv_pipe_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_poll_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub poll_cb: uv_poll_cb,
    pub io_watcher: uv__io_t,
}
#[test]
fn bindgen_test_layout_uv_poll_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_poll_s>(),
        128usize,
        concat!("Size of: ", stringify!(uv_poll_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_poll_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_poll_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).poll_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(poll_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).io_watcher as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(io_watcher)
        )
    );
}
pub const uv_poll_event_UV_READABLE: uv_poll_event = 1;
pub const uv_poll_event_UV_WRITABLE: uv_poll_event = 2;
pub const uv_poll_event_UV_DISCONNECT: uv_poll_event = 4;
pub const uv_poll_event_UV_PRIORITIZED: uv_poll_event = 8;
pub type uv_poll_event = u32;
extern "C" {
    pub fn uv_poll_init(
        loop_: *mut uv_loop_t,
        handle: *mut uv_poll_t,
        socket: uv_os_sock_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_poll_start(
        handle: *mut uv_poll_t,
        events: ::std::os::raw::c_int,
        cb: uv_poll_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_poll_stop(handle: *mut uv_poll_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_prepare_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub prepare_cb: uv_prepare_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_uv_prepare_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_prepare_s>(),
        88usize,
        concat!("Size of: ", stringify!(uv_prepare_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_prepare_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_prepare_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).prepare_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(prepare_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).queue as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(queue)
        )
    );
}
extern "C" {
    pub fn uv_prepare_init(
        arg1: *mut uv_loop_t,
        prepare: *mut uv_prepare_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_prepare_start(prepare: *mut uv_prepare_t, cb: uv_prepare_cb)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_prepare_stop(prepare: *mut uv_prepare_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_check_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub check_cb: uv_check_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_uv_check_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_check_s>(),
        88usize,
        concat!("Size of: ", stringify!(uv_check_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_check_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_check_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).check_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(check_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).queue as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(queue)
        )
    );
}
extern "C" {
    pub fn uv_check_init(arg1: *mut uv_loop_t, check: *mut uv_check_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_check_start(check: *mut uv_check_t, cb: uv_check_cb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_check_stop(check: *mut uv_check_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_idle_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub idle_cb: uv_idle_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_uv_idle_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_idle_s>(),
        88usize,
        concat!("Size of: ", stringify!(uv_idle_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_idle_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_idle_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).idle_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(idle_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).queue as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(queue)
        )
    );
}
extern "C" {
    pub fn uv_idle_init(arg1: *mut uv_loop_t, idle: *mut uv_idle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_idle_start(idle: *mut uv_idle_t, cb: uv_idle_cb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_idle_stop(idle: *mut uv_idle_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_async_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub async_cb: uv_async_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub pending: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_async_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_async_s>(),
        96usize,
        concat!("Size of: ", stringify!(uv_async_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_async_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_async_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).async_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(async_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).queue as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).pending as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(pending)
        )
    );
}
extern "C" {
    pub fn uv_async_init(
        arg1: *mut uv_loop_t,
        async_: *mut uv_async_t,
        async_cb: uv_async_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_async_send(async_: *mut uv_async_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_timer_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub timer_cb: uv_timer_cb,
    pub heap_node: [*mut ::std::os::raw::c_void; 3usize],
    pub timeout: u64,
    pub repeat: u64,
    pub start_id: u64,
}
#[test]
fn bindgen_test_layout_uv_timer_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_timer_s>(),
        120usize,
        concat!("Size of: ", stringify!(uv_timer_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_timer_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_timer_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).timer_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(timer_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).heap_node as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(heap_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).timeout as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).repeat as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).start_id as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(start_id)
        )
    );
}
extern "C" {
    pub fn uv_timer_init(arg1: *mut uv_loop_t, handle: *mut uv_timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_timer_start(
        handle: *mut uv_timer_t,
        cb: uv_timer_cb,
        timeout: u64,
        repeat: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_timer_stop(handle: *mut uv_timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_timer_again(handle: *mut uv_timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_timer_set_repeat(handle: *mut uv_timer_t, repeat: u64);
}
extern "C" {
    pub fn uv_timer_get_repeat(handle: *const uv_timer_t) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_getaddrinfo_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub reserved: [*mut ::std::os::raw::c_void; 6usize],
    pub loop_: *mut uv_loop_t,
    pub work_req: uv__work,
    pub cb: uv_getaddrinfo_cb,
    pub hints: *mut addrinfo,
    pub hostname: *mut ::std::os::raw::c_char,
    pub service: *mut ::std::os::raw::c_char,
    pub addrinfo: *mut addrinfo,
    pub retcode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_getaddrinfo_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_getaddrinfo_s>(),
        160usize,
        concat!("Size of: ", stringify!(uv_getaddrinfo_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_getaddrinfo_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_getaddrinfo_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).loop_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).work_req as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(work_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).cb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).hints as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(hints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).hostname as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).service as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).addrinfo as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(addrinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).retcode as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(retcode)
        )
    );
}
extern "C" {
    pub fn uv_getaddrinfo(
        loop_: *mut uv_loop_t,
        req: *mut uv_getaddrinfo_t,
        getaddrinfo_cb: uv_getaddrinfo_cb,
        node: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hints: *const addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_freeaddrinfo(ai: *mut addrinfo);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_getnameinfo_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub reserved: [*mut ::std::os::raw::c_void; 6usize],
    pub loop_: *mut uv_loop_t,
    pub work_req: uv__work,
    pub getnameinfo_cb: uv_getnameinfo_cb,
    pub storage: sockaddr_storage,
    pub flags: ::std::os::raw::c_int,
    pub host: [::std::os::raw::c_char; 1025usize],
    pub service: [::std::os::raw::c_char; 32usize],
    pub retcode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_getnameinfo_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_getnameinfo_s>(),
        1320usize,
        concat!("Size of: ", stringify!(uv_getnameinfo_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_getnameinfo_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_getnameinfo_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).loop_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).work_req as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(work_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).getnameinfo_cb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(getnameinfo_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).storage as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).flags as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).host as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).service as *const _ as usize },
        1277usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).retcode as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(retcode)
        )
    );
}
extern "C" {
    pub fn uv_getnameinfo(
        loop_: *mut uv_loop_t,
        req: *mut uv_getnameinfo_t,
        getnameinfo_cb: uv_getnameinfo_cb,
        addr: *const sockaddr,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const uv_stdio_flags_UV_IGNORE: uv_stdio_flags = 0;
pub const uv_stdio_flags_UV_CREATE_PIPE: uv_stdio_flags = 1;
pub const uv_stdio_flags_UV_INHERIT_FD: uv_stdio_flags = 2;
pub const uv_stdio_flags_UV_INHERIT_STREAM: uv_stdio_flags = 4;
pub const uv_stdio_flags_UV_READABLE_PIPE: uv_stdio_flags = 16;
pub const uv_stdio_flags_UV_WRITABLE_PIPE: uv_stdio_flags = 32;
pub const uv_stdio_flags_UV_NONBLOCK_PIPE: uv_stdio_flags = 64;
pub const uv_stdio_flags_UV_OVERLAPPED_PIPE: uv_stdio_flags = 64;
pub type uv_stdio_flags = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_stdio_container_s {
    pub flags: uv_stdio_flags,
    pub data: uv_stdio_container_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_stdio_container_s__bindgen_ty_1 {
    pub stream: *mut uv_stream_t,
    pub file: uv_os_fd_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_uv_stdio_container_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_stdio_container_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(uv_stdio_container_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stdio_container_s__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uv_stdio_container_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_stdio_container_s__bindgen_ty_1>())).stream as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stdio_container_s__bindgen_ty_1),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_stdio_container_s__bindgen_ty_1>())).file as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stdio_container_s__bindgen_ty_1),
            "::",
            stringify!(file)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_stdio_container_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_stdio_container_s>(),
        16usize,
        concat!("Size of: ", stringify!(uv_stdio_container_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stdio_container_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_stdio_container_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stdio_container_s>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stdio_container_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stdio_container_s>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stdio_container_s),
            "::",
            stringify!(data)
        )
    );
}
pub type uv_stdio_container_t = uv_stdio_container_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_process_options_s {
    pub exit_cb: uv_exit_cb,
    pub file: *const ::std::os::raw::c_char,
    pub args: *mut *mut ::std::os::raw::c_char,
    pub env: *mut *mut ::std::os::raw::c_char,
    pub cwd: *const ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_uint,
    pub stdio_count: ::std::os::raw::c_int,
    pub stdio: *mut uv_stdio_container_t,
    pub uid: uv_uid_t,
    pub gid: uv_gid_t,
    pub cpumask: *mut ::std::os::raw::c_char,
    pub cpumask_size: usize,
}
#[test]
fn bindgen_test_layout_uv_process_options_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_process_options_s>(),
        80usize,
        concat!("Size of: ", stringify!(uv_process_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_process_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_process_options_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).exit_cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(exit_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).env as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).cwd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_process_options_s>())).stdio_count as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(stdio_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).stdio as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(stdio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).uid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).gid as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).cpumask as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(cpumask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_process_options_s>())).cpumask_size as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(cpumask_size)
        )
    );
}
pub type uv_process_options_t = uv_process_options_s;
pub const uv_process_flags_UV_PROCESS_SETUID: uv_process_flags = 1;
pub const uv_process_flags_UV_PROCESS_SETGID: uv_process_flags = 2;
pub const uv_process_flags_UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS: uv_process_flags = 4;
pub const uv_process_flags_UV_PROCESS_DETACHED: uv_process_flags = 8;
pub const uv_process_flags_UV_PROCESS_WINDOWS_HIDE: uv_process_flags = 16;
pub const uv_process_flags_UV_PROCESS_WINDOWS_HIDE_CONSOLE: uv_process_flags = 32;
pub const uv_process_flags_UV_PROCESS_WINDOWS_HIDE_GUI: uv_process_flags = 64;
pub type uv_process_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_process_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub exit_cb: uv_exit_cb,
    pub pid: ::std::os::raw::c_int,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub status: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_process_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_process_s>(),
        104usize,
        concat!("Size of: ", stringify!(uv_process_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_process_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_process_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).exit_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(exit_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).pid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).queue as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).status as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    pub fn uv_spawn(
        loop_: *mut uv_loop_t,
        handle: *mut uv_process_t,
        options: *const uv_process_options_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_process_kill(
        arg1: *mut uv_process_t,
        signum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_kill(
        pid: ::std::os::raw::c_int,
        signum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_process_get_pid(arg1: *const uv_process_t) -> uv_pid_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_work_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub reserved: [*mut ::std::os::raw::c_void; 6usize],
    pub loop_: *mut uv_loop_t,
    pub work_cb: uv_work_cb,
    pub after_work_cb: uv_after_work_cb,
    pub work_req: uv__work,
}
#[test]
fn bindgen_test_layout_uv_work_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_work_s>(),
        128usize,
        concat!("Size of: ", stringify!(uv_work_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_work_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_work_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).loop_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).work_cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(work_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).after_work_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(after_work_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).work_req as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(work_req)
        )
    );
}
extern "C" {
    pub fn uv_queue_work(
        loop_: *mut uv_loop_t,
        req: *mut uv_work_t,
        work_cb: uv_work_cb,
        after_work_cb: uv_after_work_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_cancel(req: *mut uv_req_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_cpu_times_s {
    pub user: u64,
    pub nice: u64,
    pub sys: u64,
    pub idle: u64,
    pub irq: u64,
}
#[test]
fn bindgen_test_layout_uv_cpu_times_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_cpu_times_s>(),
        40usize,
        concat!("Size of: ", stringify!(uv_cpu_times_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_cpu_times_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_cpu_times_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_times_s>())).user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_times_s),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_times_s>())).nice as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_times_s),
            "::",
            stringify!(nice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_times_s>())).sys as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_times_s),
            "::",
            stringify!(sys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_times_s>())).idle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_times_s),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_times_s>())).irq as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_times_s),
            "::",
            stringify!(irq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_cpu_info_s {
    pub model: *mut ::std::os::raw::c_char,
    pub speed: ::std::os::raw::c_int,
    pub cpu_times: uv_cpu_times_s,
}
#[test]
fn bindgen_test_layout_uv_cpu_info_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_cpu_info_s>(),
        56usize,
        concat!("Size of: ", stringify!(uv_cpu_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_cpu_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_cpu_info_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_info_s>())).model as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_info_s>())).speed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_info_s>())).cpu_times as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s),
            "::",
            stringify!(cpu_times)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_interface_address_s {
    pub name: *mut ::std::os::raw::c_char,
    pub phys_addr: [::std::os::raw::c_char; 6usize],
    pub is_internal: ::std::os::raw::c_int,
    pub address: uv_interface_address_s__bindgen_ty_1,
    pub netmask: uv_interface_address_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_interface_address_s__bindgen_ty_1 {
    pub address4: sockaddr_in,
    pub address6: sockaddr_in6,
    _bindgen_union_align: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_uv_interface_address_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_interface_address_s__bindgen_ty_1>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(uv_interface_address_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uv_interface_address_s__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(uv_interface_address_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s__bindgen_ty_1>())).address4 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s__bindgen_ty_1),
            "::",
            stringify!(address4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s__bindgen_ty_1>())).address6 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s__bindgen_ty_1),
            "::",
            stringify!(address6)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_interface_address_s__bindgen_ty_2 {
    pub netmask4: sockaddr_in,
    pub netmask6: sockaddr_in6,
    _bindgen_union_align: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_uv_interface_address_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<uv_interface_address_s__bindgen_ty_2>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(uv_interface_address_s__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uv_interface_address_s__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(uv_interface_address_s__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s__bindgen_ty_2>())).netmask4 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s__bindgen_ty_2),
            "::",
            stringify!(netmask4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s__bindgen_ty_2>())).netmask6 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s__bindgen_ty_2),
            "::",
            stringify!(netmask6)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_interface_address_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_interface_address_s>(),
        80usize,
        concat!("Size of: ", stringify!(uv_interface_address_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_interface_address_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_interface_address_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_interface_address_s>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s>())).phys_addr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s>())).is_internal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(is_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_interface_address_s>())).address as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_interface_address_s>())).netmask as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(netmask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_passwd_s {
    pub username: *mut ::std::os::raw::c_char,
    pub uid: ::std::os::raw::c_long,
    pub gid: ::std::os::raw::c_long,
    pub shell: *mut ::std::os::raw::c_char,
    pub homedir: *mut ::std::os::raw::c_char,
    pub gecos: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uv_passwd_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_passwd_s>(),
        48usize,
        concat!("Size of: ", stringify!(uv_passwd_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_passwd_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_passwd_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).username as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).uid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).gid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).shell as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(shell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).homedir as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(homedir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).gecos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(gecos)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_utsname_s {
    pub sysname: [::std::os::raw::c_char; 256usize],
    pub release: [::std::os::raw::c_char; 256usize],
    pub version: [::std::os::raw::c_char; 256usize],
    pub machine: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_uv_utsname_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_utsname_s>(),
        1024usize,
        concat!("Size of: ", stringify!(uv_utsname_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_utsname_s>(),
        1usize,
        concat!("Alignment of ", stringify!(uv_utsname_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_utsname_s>())).sysname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_utsname_s),
            "::",
            stringify!(sysname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_utsname_s>())).release as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_utsname_s),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_utsname_s>())).version as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_utsname_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_utsname_s>())).machine as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_utsname_s),
            "::",
            stringify!(machine)
        )
    );
}
pub const uv_dirent_type_t_UV_DIRENT_UNKNOWN: uv_dirent_type_t = 0;
pub const uv_dirent_type_t_UV_DIRENT_FILE: uv_dirent_type_t = 1;
pub const uv_dirent_type_t_UV_DIRENT_DIR: uv_dirent_type_t = 2;
pub const uv_dirent_type_t_UV_DIRENT_LINK: uv_dirent_type_t = 3;
pub const uv_dirent_type_t_UV_DIRENT_FIFO: uv_dirent_type_t = 4;
pub const uv_dirent_type_t_UV_DIRENT_SOCKET: uv_dirent_type_t = 5;
pub const uv_dirent_type_t_UV_DIRENT_CHAR: uv_dirent_type_t = 6;
pub const uv_dirent_type_t_UV_DIRENT_BLOCK: uv_dirent_type_t = 7;
pub type uv_dirent_type_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_dirent_s {
    pub name: *const ::std::os::raw::c_char,
    pub type_: uv_dirent_type_t,
}
#[test]
fn bindgen_test_layout_uv_dirent_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_dirent_s>(),
        16usize,
        concat!("Size of: ", stringify!(uv_dirent_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_dirent_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_dirent_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_dirent_s>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_dirent_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_dirent_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_dirent_s),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    pub fn uv_setup_args(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn uv_get_process_title(
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_set_process_title(title: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_resident_set_memory(rss: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_uptime(uptime: *mut f64) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_timeval_t {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_uv_timeval_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_timeval_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_timeval_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_timeval_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_timeval_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timeval_t>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timeval_t),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timeval_t>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timeval_t),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_timeval64_t {
    pub tv_sec: i64,
    pub tv_usec: i32,
}
#[test]
fn bindgen_test_layout_uv_timeval64_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_timeval64_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_timeval64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_timeval64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_timeval64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timeval64_t>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timeval64_t),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timeval64_t>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timeval64_t),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_rusage_t {
    pub ru_utime: uv_timeval_t,
    pub ru_stime: uv_timeval_t,
    pub ru_maxrss: u64,
    pub ru_ixrss: u64,
    pub ru_idrss: u64,
    pub ru_isrss: u64,
    pub ru_minflt: u64,
    pub ru_majflt: u64,
    pub ru_nswap: u64,
    pub ru_inblock: u64,
    pub ru_oublock: u64,
    pub ru_msgsnd: u64,
    pub ru_msgrcv: u64,
    pub ru_nsignals: u64,
    pub ru_nvcsw: u64,
    pub ru_nivcsw: u64,
}
#[test]
fn bindgen_test_layout_uv_rusage_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_rusage_t>(),
        144usize,
        concat!("Size of: ", stringify!(uv_rusage_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_rusage_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_rusage_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
extern "C" {
    pub fn uv_getrusage(rusage: *mut uv_rusage_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_os_homedir(
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_os_tmpdir(
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_os_get_passwd(pwd: *mut uv_passwd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_os_free_passwd(pwd: *mut uv_passwd_t);
}
extern "C" {
    pub fn uv_os_getpid() -> uv_pid_t;
}
extern "C" {
    pub fn uv_os_getppid() -> uv_pid_t;
}
extern "C" {
    pub fn uv_os_getpriority(
        pid: uv_pid_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_os_setpriority(
        pid: uv_pid_t,
        priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_cpu_info(
        cpu_infos: *mut *mut uv_cpu_info_t,
        count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_free_cpu_info(cpu_infos: *mut uv_cpu_info_t, count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn uv_cpumask_size() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_interface_addresses(
        addresses: *mut *mut uv_interface_address_t,
        count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_free_interface_addresses(
        addresses: *mut uv_interface_address_t,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn uv_os_getenv(
        name: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_os_setenv(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_os_unsetenv(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_os_gethostname(
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_os_uname(buffer: *mut uv_utsname_t) -> ::std::os::raw::c_int;
}
pub const uv_fs_type_UV_FS_UNKNOWN: uv_fs_type = -1;
pub const uv_fs_type_UV_FS_CUSTOM: uv_fs_type = 0;
pub const uv_fs_type_UV_FS_OPEN: uv_fs_type = 1;
pub const uv_fs_type_UV_FS_CLOSE: uv_fs_type = 2;
pub const uv_fs_type_UV_FS_READ: uv_fs_type = 3;
pub const uv_fs_type_UV_FS_WRITE: uv_fs_type = 4;
pub const uv_fs_type_UV_FS_SENDFILE: uv_fs_type = 5;
pub const uv_fs_type_UV_FS_STAT: uv_fs_type = 6;
pub const uv_fs_type_UV_FS_LSTAT: uv_fs_type = 7;
pub const uv_fs_type_UV_FS_FSTAT: uv_fs_type = 8;
pub const uv_fs_type_UV_FS_FTRUNCATE: uv_fs_type = 9;
pub const uv_fs_type_UV_FS_UTIME: uv_fs_type = 10;
pub const uv_fs_type_UV_FS_FUTIME: uv_fs_type = 11;
pub const uv_fs_type_UV_FS_ACCESS: uv_fs_type = 12;
pub const uv_fs_type_UV_FS_CHMOD: uv_fs_type = 13;
pub const uv_fs_type_UV_FS_FCHMOD: uv_fs_type = 14;
pub const uv_fs_type_UV_FS_FSYNC: uv_fs_type = 15;
pub const uv_fs_type_UV_FS_FDATASYNC: uv_fs_type = 16;
pub const uv_fs_type_UV_FS_UNLINK: uv_fs_type = 17;
pub const uv_fs_type_UV_FS_RMDIR: uv_fs_type = 18;
pub const uv_fs_type_UV_FS_MKDIR: uv_fs_type = 19;
pub const uv_fs_type_UV_FS_MKDTEMP: uv_fs_type = 20;
pub const uv_fs_type_UV_FS_RENAME: uv_fs_type = 21;
pub const uv_fs_type_UV_FS_SCANDIR: uv_fs_type = 22;
pub const uv_fs_type_UV_FS_LINK: uv_fs_type = 23;
pub const uv_fs_type_UV_FS_SYMLINK: uv_fs_type = 24;
pub const uv_fs_type_UV_FS_READLINK: uv_fs_type = 25;
pub const uv_fs_type_UV_FS_CHOWN: uv_fs_type = 26;
pub const uv_fs_type_UV_FS_FCHOWN: uv_fs_type = 27;
pub const uv_fs_type_UV_FS_LCHOWN: uv_fs_type = 28;
pub const uv_fs_type_UV_FS_REALPATH: uv_fs_type = 29;
pub const uv_fs_type_UV_FS_COPYFILE: uv_fs_type = 30;
pub const uv_fs_type_UV_FS_OPENDIR: uv_fs_type = 31;
pub const uv_fs_type_UV_FS_READDIR: uv_fs_type = 32;
pub const uv_fs_type_UV_FS_CLOSEDIR: uv_fs_type = 33;
pub type uv_fs_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_dir_s {
    pub dirents: *mut uv_dirent_t,
    pub nentries: usize,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub dir: *mut DIR,
}
#[test]
fn bindgen_test_layout_uv_dir_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_dir_s>(),
        56usize,
        concat!("Size of: ", stringify!(uv_dir_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_dir_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_dir_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_dir_s>())).dirents as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_dir_s),
            "::",
            stringify!(dirents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_dir_s>())).nentries as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_dir_s),
            "::",
            stringify!(nentries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_dir_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_dir_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_dir_s>())).dir as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_dir_s),
            "::",
            stringify!(dir)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_fs_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub reserved: [*mut ::std::os::raw::c_void; 6usize],
    pub fs_type: uv_fs_type,
    pub loop_: *mut uv_loop_t,
    pub cb: uv_fs_cb,
    pub result: isize,
    pub ptr: *mut ::std::os::raw::c_void,
    pub path: *const ::std::os::raw::c_char,
    pub statbuf: uv_stat_t,
    pub new_path: *const ::std::os::raw::c_char,
    pub file: uv_os_fd_t,
    pub flags: ::std::os::raw::c_int,
    pub mode: mode_t,
    pub nbufs: ::std::os::raw::c_uint,
    pub bufs: *mut uv_buf_t,
    pub off: off_t,
    pub uid: uv_uid_t,
    pub gid: uv_gid_t,
    pub btime: f64,
    pub atime: f64,
    pub mtime: f64,
    pub work_req: uv__work,
    pub bufsml: [uv_buf_t; 4usize],
}
#[test]
fn bindgen_test_layout_uv_fs_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_fs_s>(),
        448usize,
        concat!("Size of: ", stringify!(uv_fs_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_fs_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_fs_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).fs_type as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(fs_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).loop_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).result as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).ptr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).path as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).statbuf as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(statbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).new_path as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(new_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).file as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).flags as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).mode as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).nbufs as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(nbufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).bufs as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).off as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).uid as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).gid as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).btime as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).atime as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).mtime as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).work_req as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(work_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).bufsml as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(bufsml)
        )
    );
}
extern "C" {
    pub fn uv_fs_get_type(arg1: *const uv_fs_t) -> uv_fs_type;
}
extern "C" {
    pub fn uv_fs_get_result(arg1: *const uv_fs_t) -> isize;
}
extern "C" {
    pub fn uv_fs_get_ptr(arg1: *const uv_fs_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn uv_fs_get_path(arg1: *const uv_fs_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uv_fs_get_statbuf(arg1: *mut uv_fs_t) -> *mut uv_stat_t;
}
extern "C" {
    pub fn uv_fs_req_cleanup(req: *mut uv_fs_t);
}
extern "C" {
    pub fn uv_fs_close(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_open(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_read(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        offset: i64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_unlink(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_write(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        offset: i64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_copyfile(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        new_path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_mkdir(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_mkdtemp(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        tpl: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_rmdir(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_scandir(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_scandir_next(req: *mut uv_fs_t, ent: *mut uv_dirent_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_opendir(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_readdir(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        dir: *mut uv_dir_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_closedir(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        dir: *mut uv_dir_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_stat(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_fstat(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_rename(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        new_path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_fsync(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_fdatasync(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_ftruncate(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        offset: i64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_sendfile(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        out_fd: uv_os_fd_t,
        in_fd: uv_os_fd_t,
        in_offset: i64,
        length: usize,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_access(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_chmod(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_utime(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        atime: f64,
        mtime: f64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_utime_ex(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        btime: f64,
        atime: f64,
        mtime: f64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_futime(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        atime: f64,
        mtime: f64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_futime_ex(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        btime: f64,
        atime: f64,
        mtime: f64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_lstat(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_link(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        new_path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_symlink(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        new_path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_readlink(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_realpath(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_fchmod(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_chown(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        uid: uv_uid_t,
        gid: uv_gid_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_fchown(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_os_fd_t,
        uid: uv_uid_t,
        gid: uv_gid_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_lchown(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        uid: uv_uid_t,
        gid: uv_gid_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
pub const uv_fs_event_UV_RENAME: uv_fs_event = 1;
pub const uv_fs_event_UV_CHANGE: uv_fs_event = 2;
pub type uv_fs_event = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_fs_event_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub path: *mut ::std::os::raw::c_char,
    pub cb: uv_fs_event_cb,
    pub watchers: [*mut ::std::os::raw::c_void; 2usize],
    pub wd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_fs_event_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_fs_event_s>(),
        104usize,
        concat!("Size of: ", stringify!(uv_fs_event_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_fs_event_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_fs_event_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).path as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).watchers as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(watchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).wd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(wd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_fs_poll_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub poll_ctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_uv_fs_poll_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_fs_poll_s>(),
        72usize,
        concat!("Size of: ", stringify!(uv_fs_poll_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_fs_poll_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_fs_poll_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).poll_ctx as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(poll_ctx)
        )
    );
}
extern "C" {
    pub fn uv_fs_poll_init(
        loop_: *mut uv_loop_t,
        handle: *mut uv_fs_poll_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_poll_start(
        handle: *mut uv_fs_poll_t,
        poll_cb: uv_fs_poll_cb,
        path: *const ::std::os::raw::c_char,
        interval: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_poll_stop(handle: *mut uv_fs_poll_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_poll_getpath(
        handle: *mut uv_fs_poll_t,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_signal_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub signal_cb: uv_signal_cb,
    pub signum: ::std::os::raw::c_int,
    pub tree_entry: uv_signal_s__bindgen_ty_1,
    pub caught_signals: ::std::os::raw::c_uint,
    pub dispatched_signals: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_signal_s__bindgen_ty_1 {
    pub rbe_left: *mut uv_signal_s,
    pub rbe_right: *mut uv_signal_s,
    pub rbe_parent: *mut uv_signal_s,
    pub rbe_color: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_signal_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_signal_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).rbe_left as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(rbe_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).rbe_right as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(rbe_right)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).rbe_parent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(rbe_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).rbe_color as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(rbe_color)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_signal_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s>(),
        120usize,
        concat!("Size of: ", stringify!(uv_signal_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).signal_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(signal_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).signum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(signum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).tree_entry as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(tree_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).caught_signals as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(caught_signals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).dispatched_signals as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(dispatched_signals)
        )
    );
}
extern "C" {
    pub fn uv_signal_init(loop_: *mut uv_loop_t, handle: *mut uv_signal_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_signal_start(
        handle: *mut uv_signal_t,
        signal_cb: uv_signal_cb,
        signum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_signal_start_oneshot(
        handle: *mut uv_signal_t,
        signal_cb: uv_signal_cb,
        signum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_signal_stop(handle: *mut uv_signal_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_loadavg(avg: *mut f64);
}
pub const uv_fs_event_flags_UV_FS_EVENT_WATCH_ENTRY: uv_fs_event_flags = 1;
pub const uv_fs_event_flags_UV_FS_EVENT_STAT: uv_fs_event_flags = 2;
pub const uv_fs_event_flags_UV_FS_EVENT_RECURSIVE: uv_fs_event_flags = 4;
pub type uv_fs_event_flags = u32;
extern "C" {
    pub fn uv_fs_event_init(
        loop_: *mut uv_loop_t,
        handle: *mut uv_fs_event_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_event_start(
        handle: *mut uv_fs_event_t,
        cb: uv_fs_event_cb,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_event_stop(handle: *mut uv_fs_event_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_fs_event_getpath(
        handle: *mut uv_fs_event_t,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_ip4_addr(
        ip: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        addr: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_ip6_addr(
        ip: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        addr: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_ip4_name(
        src: *const sockaddr_in,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_ip6_name(
        src: *const sockaddr_in6,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_inet_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_inet_pton(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_if_indextoname(
        ifindex: ::std::os::raw::c_uint,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_if_indextoiid(
        ifindex: ::std::os::raw::c_uint,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_exepath(
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_cwd(buffer: *mut ::std::os::raw::c_char, size: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_chdir(dir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_get_free_memory() -> u64;
}
extern "C" {
    pub fn uv_get_total_memory() -> u64;
}
extern "C" {
    pub fn uv_get_constrained_memory() -> u64;
}
extern "C" {
    pub fn uv_hrtime() -> u64;
}
extern "C" {
    pub fn uv_disable_stdio_inheritance();
}
extern "C" {
    pub fn uv_dlopen(
        filename: *const ::std::os::raw::c_char,
        lib: *mut uv_lib_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_dlclose(lib: *mut uv_lib_t);
}
extern "C" {
    pub fn uv_dlsym(
        lib: *mut uv_lib_t,
        name: *const ::std::os::raw::c_char,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_dlerror(lib: *const uv_lib_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uv_mutex_init(handle: *mut uv_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_mutex_init_recursive(handle: *mut uv_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_mutex_destroy(handle: *mut uv_mutex_t);
}
extern "C" {
    pub fn uv_mutex_lock(handle: *mut uv_mutex_t);
}
extern "C" {
    pub fn uv_mutex_trylock(handle: *mut uv_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_mutex_unlock(handle: *mut uv_mutex_t);
}
extern "C" {
    pub fn uv_rwlock_init(rwlock: *mut uv_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_rwlock_destroy(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    pub fn uv_rwlock_rdlock(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    pub fn uv_rwlock_tryrdlock(rwlock: *mut uv_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_rwlock_rdunlock(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    pub fn uv_rwlock_wrlock(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    pub fn uv_rwlock_trywrlock(rwlock: *mut uv_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_rwlock_wrunlock(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    pub fn uv_sem_init(sem: *mut uv_sem_t, value: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_sem_destroy(sem: *mut uv_sem_t);
}
extern "C" {
    pub fn uv_sem_post(sem: *mut uv_sem_t);
}
extern "C" {
    pub fn uv_sem_wait(sem: *mut uv_sem_t);
}
extern "C" {
    pub fn uv_sem_trywait(sem: *mut uv_sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_cond_init(cond: *mut uv_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_cond_destroy(cond: *mut uv_cond_t);
}
extern "C" {
    pub fn uv_cond_signal(cond: *mut uv_cond_t);
}
extern "C" {
    pub fn uv_cond_broadcast(cond: *mut uv_cond_t);
}
extern "C" {
    pub fn uv_barrier_init(
        barrier: *mut uv_barrier_t,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_barrier_destroy(barrier: *mut uv_barrier_t);
}
extern "C" {
    pub fn uv_barrier_wait(barrier: *mut uv_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_cond_wait(cond: *mut uv_cond_t, mutex: *mut uv_mutex_t);
}
extern "C" {
    pub fn uv_cond_timedwait(
        cond: *mut uv_cond_t,
        mutex: *mut uv_mutex_t,
        timeout: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_once(guard: *mut uv_once_t, callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn uv_key_create(key: *mut uv_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_key_delete(key: *mut uv_key_t);
}
extern "C" {
    pub fn uv_key_get(key: *mut uv_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn uv_key_set(key: *mut uv_key_t, value: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uv_gettimeofday(tv: *mut uv_timeval64_t) -> ::std::os::raw::c_int;
}
pub type uv_thread_cb =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn uv_thread_create(
        tid: *mut uv_thread_t,
        entry: uv_thread_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const uv_thread_create_flags_UV_THREAD_NO_FLAGS: uv_thread_create_flags = 0;
pub const uv_thread_create_flags_UV_THREAD_HAS_STACK_SIZE: uv_thread_create_flags = 1;
pub type uv_thread_create_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_thread_options_s {
    pub flags: ::std::os::raw::c_uint,
    pub stack_size: usize,
}
#[test]
fn bindgen_test_layout_uv_thread_options_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_thread_options_s>(),
        16usize,
        concat!("Size of: ", stringify!(uv_thread_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_thread_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_thread_options_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_thread_options_s>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_thread_options_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_thread_options_s>())).stack_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_thread_options_s),
            "::",
            stringify!(stack_size)
        )
    );
}
pub type uv_thread_options_t = uv_thread_options_s;
extern "C" {
    pub fn uv_thread_create_ex(
        tid: *mut uv_thread_t,
        params: *const uv_thread_options_t,
        entry: uv_thread_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_thread_setaffinity(
        tid: *mut uv_thread_t,
        cpumask: *mut ::std::os::raw::c_char,
        oldmask: *mut ::std::os::raw::c_char,
        mask_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_thread_getaffinity(
        tid: *mut uv_thread_t,
        cpumask: *mut ::std::os::raw::c_char,
        mask_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_thread_detach(tid: *mut uv_thread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_thread_join(tid: *mut uv_thread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uv_thread_self() -> uv_thread_t;
}
extern "C" {
    pub fn uv_thread_equal(t1: *const uv_thread_t, t2: *const uv_thread_t)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_any_handle {
    pub async_: uv_async_t,
    pub check: uv_check_t,
    pub fs_event: uv_fs_event_t,
    pub fs_poll: uv_fs_poll_t,
    pub handle: uv_handle_t,
    pub idle: uv_idle_t,
    pub pipe: uv_pipe_t,
    pub poll: uv_poll_t,
    pub prepare: uv_prepare_t,
    pub process: uv_process_t,
    pub stream: uv_stream_t,
    pub tcp: uv_tcp_t,
    pub timer: uv_timer_t,
    pub tty: uv_tty_t,
    pub udp: uv_udp_t,
    pub signal: uv_signal_t,
    _bindgen_union_align: [u64; 35usize],
}
#[test]
fn bindgen_test_layout_uv_any_handle() {
    assert_eq!(
        ::std::mem::size_of::<uv_any_handle>(),
        280usize,
        concat!("Size of: ", stringify!(uv_any_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_any_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_any_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).async_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(async_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).check as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).fs_event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(fs_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).fs_poll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(fs_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).idle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).pipe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).poll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).prepare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).process as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).stream as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).tcp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(tcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).tty as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(tty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).udp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(udp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).signal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(signal)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_any_req {
    pub req: uv_req_t,
    pub connect: uv_connect_t,
    pub write: uv_write_t,
    pub shutdown: uv_shutdown_t,
    pub udp_send: uv_udp_send_t,
    pub fs: uv_fs_t,
    pub work: uv_work_t,
    pub getaddrinfo: uv_getaddrinfo_t,
    pub getnameinfo: uv_getnameinfo_t,
    _bindgen_union_align: [u64; 165usize],
}
#[test]
fn bindgen_test_layout_uv_any_req() {
    assert_eq!(
        ::std::mem::size_of::<uv_any_req>(),
        1320usize,
        concat!("Size of: ", stringify!(uv_any_req))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_any_req>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_any_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).req as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).connect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).shutdown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).udp_send as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(udp_send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).getaddrinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(getaddrinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).getnameinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(getnameinfo)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_loop_s {
    pub data: *mut ::std::os::raw::c_void,
    pub active_handles: ::std::os::raw::c_uint,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub active_reqs: uv_loop_s__bindgen_ty_1,
    pub stop_flag: ::std::os::raw::c_uint,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub flags: ::std::os::raw::c_ulong,
    pub backend_fd: ::std::os::raw::c_int,
    pub pending_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watcher_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watchers: *mut *mut uv__io_t,
    pub nwatchers: ::std::os::raw::c_uint,
    pub nfds: ::std::os::raw::c_uint,
    pub wq: [*mut ::std::os::raw::c_void; 2usize],
    pub wq_mutex: uv_mutex_t,
    pub wq_async: uv_async_t,
    pub cloexec_lock: uv_rwlock_t,
    pub closing_handles: *mut uv_handle_t,
    pub process_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub prepare_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub check_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub idle_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub async_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub async_unused: ::std::option::Option<unsafe extern "C" fn()>,
    pub async_io_watcher: uv__io_t,
    pub async_wfd: ::std::os::raw::c_int,
    pub timer_heap: uv_loop_s__bindgen_ty_2,
    pub timer_counter: u64,
    pub time: u64,
    pub signal_pipefd: [::std::os::raw::c_int; 2usize],
    pub signal_io_watcher: uv__io_t,
    pub child_watcher: uv_signal_t,
    pub emfile_fd: ::std::os::raw::c_int,
    pub inotify_read_watcher: uv__io_t,
    pub inotify_watchers: *mut ::std::os::raw::c_void,
    pub inotify_fd: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_loop_s__bindgen_ty_1 {
    pub unused: [*mut ::std::os::raw::c_void; 2usize],
    pub count: ::std::os::raw::c_uint,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_uv_loop_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(uv_loop_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_1>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_1),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_1>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_loop_s__bindgen_ty_2 {
    pub min: *mut ::std::os::raw::c_void,
    pub nelts: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uv_loop_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(uv_loop_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_2>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_2),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_2>())).nelts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_2),
            "::",
            stringify!(nelts)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_loop_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s>(),
        816usize,
        concat!("Size of: ", stringify!(uv_loop_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).active_handles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(active_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).handle_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).active_reqs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(active_reqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).stop_flag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(stop_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).backend_fd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(backend_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).pending_queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(pending_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).watcher_queue as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(watcher_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).watchers as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(watchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).nwatchers as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(nwatchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).nfds as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq_mutex as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq_async as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cloexec_lock as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cloexec_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).closing_handles as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(closing_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).process_handles as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(process_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).prepare_handles as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(prepare_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).check_handles as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(check_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).idle_handles as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(idle_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_handles as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_unused as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_io_watcher as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_wfd as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_wfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).timer_heap as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(timer_heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).timer_counter as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(timer_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).time as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).signal_pipefd as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(signal_pipefd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).signal_io_watcher as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(signal_io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).child_watcher as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(child_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).emfile_fd as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(emfile_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).inotify_read_watcher as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(inotify_read_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).inotify_watchers as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(inotify_watchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).inotify_fd as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(inotify_fd)
        )
    );
}
extern "C" {
    pub fn uv_loop_get_data(arg1: *const uv_loop_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn uv_loop_set_data(arg1: *mut uv_loop_t, data: *mut ::std::os::raw::c_void);
}
pub const bufmode_t_bm_none: bufmode_t = 19;
pub const bufmode_t_bm_line: bufmode_t = 20;
pub const bufmode_t_bm_block: bufmode_t = 21;
pub const bufmode_t_bm_mem: bufmode_t = 22;
pub type bufmode_t = u32;
pub const bufstate_t_bst_none: bufstate_t = 0;
pub const bufstate_t_bst_rd: bufstate_t = 1;
pub const bufstate_t_bst_wr: bufstate_t = 2;
pub type bufstate_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ios_t {
    pub buf: *mut ::std::os::raw::c_char,
    pub errcode: ::std::os::raw::c_int,
    pub _pad_bm: ::std::os::raw::c_int,
    pub bm: bufmode_t,
    pub state: bufstate_t,
    pub maxsize: i64,
    pub size: i64,
    pub bpos: i64,
    pub ndirty: i64,
    pub fpos: i64,
    pub lineno: usize,
    pub u_colno: usize,
    pub fd: ::std::os::raw::c_long,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub userdata: i64,
    pub local: [::std::os::raw::c_char; 54usize],
}
#[test]
fn bindgen_test_layout_ios_t() {
    assert_eq!(
        ::std::mem::size_of::<ios_t>(),
        160usize,
        concat!("Size of: ", stringify!(ios_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ios_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ios_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).errcode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(errcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>()))._pad_bm as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(_pad_bm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).bm as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ios_t), "::", stringify!(bm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).state as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).maxsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).bpos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(bpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).ndirty as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(ndirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).fpos as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(fpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).lineno as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(lineno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).u_colno as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(u_colno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).fd as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(ios_t), "::", stringify!(fd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).userdata as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).local as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(local)
        )
    );
}
impl ios_t {
    #[inline]
    pub fn readable(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_readable(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn writable(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_writable(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ownbuf(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ownbuf(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ownfd(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ownfd(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _eof(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__eof(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rereadable(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rereadable(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        readable: ::std::os::raw::c_uchar,
        writable: ::std::os::raw::c_uchar,
        ownbuf: ::std::os::raw::c_uchar,
        ownfd: ::std::os::raw::c_uchar,
        _eof: ::std::os::raw::c_uchar,
        rereadable: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let readable: u8 = unsafe { ::std::mem::transmute(readable) };
            readable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let writable: u8 = unsafe { ::std::mem::transmute(writable) };
            writable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ownbuf: u8 = unsafe { ::std::mem::transmute(ownbuf) };
            ownbuf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ownfd: u8 = unsafe { ::std::mem::transmute(ownfd) };
            ownfd as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let _eof: u8 = unsafe { ::std::mem::transmute(_eof) };
            _eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rereadable: u8 = unsafe { ::std::mem::transmute(rereadable) };
            rereadable as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut ios_set_io_wait_func:
        ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
}
extern "C" {
    pub fn ios_read(s: *mut ios_t, dest: *mut ::std::os::raw::c_char, n: usize) -> usize;
}
extern "C" {
    pub fn ios_readall(s: *mut ios_t, dest: *mut ::std::os::raw::c_char, n: usize) -> usize;
}
extern "C" {
    pub fn ios_write(s: *mut ios_t, data: *const ::std::os::raw::c_char, n: usize) -> usize;
}
extern "C" {
    pub fn ios_seek(s: *mut ios_t, pos: i64) -> i64;
}
extern "C" {
    pub fn ios_seek_end(s: *mut ios_t) -> i64;
}
extern "C" {
    pub fn ios_skip(s: *mut ios_t, offs: i64) -> i64;
}
extern "C" {
    pub fn ios_pos(s: *mut ios_t) -> i64;
}
extern "C" {
    pub fn ios_trunc(s: *mut ios_t, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_eof(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_eof_blocking(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_flush(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_close(s: *mut ios_t);
}
extern "C" {
    pub fn ios_isopen(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_take_buffer(s: *mut ios_t, psize: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ios_setbuf(
        s: *mut ios_t,
        buf: *mut ::std::os::raw::c_char,
        size: usize,
        own: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_bufmode(s: *mut ios_t, mode: bufmode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_get_readable(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_get_writable(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_set_readonly(s: *mut ios_t);
}
extern "C" {
    pub fn ios_copy(to: *mut ios_t, from: *mut ios_t, nbytes: usize) -> usize;
}
extern "C" {
    pub fn ios_copyall(to: *mut ios_t, from: *mut ios_t) -> usize;
}
extern "C" {
    pub fn ios_copyuntil(to: *mut ios_t, from: *mut ios_t, delim: ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn ios_nchomp(from: *mut ios_t, ntowrite: usize) -> usize;
}
extern "C" {
    pub fn ios_readprep(from: *mut ios_t, n: usize) -> usize;
}
extern "C" {
    pub fn ios_file(
        s: *mut ios_t,
        fname: *const ::std::os::raw::c_char,
        rd: ::std::os::raw::c_int,
        wr: ::std::os::raw::c_int,
        create: ::std::os::raw::c_int,
        trunc: ::std::os::raw::c_int,
    ) -> *mut ios_t;
}
extern "C" {
    pub fn ios_mkstemp(f: *mut ios_t, fname: *mut ::std::os::raw::c_char) -> *mut ios_t;
}
extern "C" {
    pub fn ios_mem(s: *mut ios_t, initsize: usize) -> *mut ios_t;
}
extern "C" {
    pub fn ios_str(s: *mut ios_t, str: *mut ::std::os::raw::c_char) -> *mut ios_t;
}
extern "C" {
    pub fn ios_static_buffer(
        s: *mut ios_t,
        buf: *mut ::std::os::raw::c_char,
        sz: usize,
    ) -> *mut ios_t;
}
extern "C" {
    pub fn ios_fd(
        s: *mut ios_t,
        fd: ::std::os::raw::c_long,
        isfile: ::std::os::raw::c_int,
        own: ::std::os::raw::c_int,
    ) -> *mut ios_t;
}
extern "C" {
    pub static mut ios_stdin: *mut ios_t;
}
extern "C" {
    pub static mut ios_stdout: *mut ios_t;
}
extern "C" {
    pub static mut ios_stderr: *mut ios_t;
}
extern "C" {
    pub fn ios_init_stdstreams();
}
extern "C" {
    pub fn ios_pututf8(s: *mut ios_t, wc: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_printf(
        s: *mut ios_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_vprintf(
        s: *mut ios_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_getutf8(s: *mut ios_t, pwc: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_peekutf8(s: *mut ios_t, pwc: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_readline(s: *mut ios_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ios_purge(s: *mut ios_t);
}
extern "C" {
    pub fn ios_putc(c: ::std::os::raw::c_int, s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_getc(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_peekc(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ios_ungetc(c: ::std::os::raw::c_int, s: *mut ios_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_timeval {
    pub sec: i64,
    pub usec: i64,
}
#[test]
fn bindgen_test_layout_jl_timeval() {
    assert_eq!(
        ::std::mem::size_of::<jl_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(jl_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_timeval>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_timeval),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_timeval>())).usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_timeval),
            "::",
            stringify!(usec)
        )
    );
}
extern "C" {
    pub fn jl_gettimeofday(jtv: *mut jl_timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_clock_now() -> f64;
}
extern "C" {
    pub fn sleep_ms(ms: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nextipow2(i: uint_t) -> uint_t;
}
extern "C" {
    pub fn int32hash(a: u32) -> u32;
}
extern "C" {
    pub fn int64hash(key: u64) -> u64;
}
extern "C" {
    pub fn int64to32hash(key: u64) -> u32;
}
extern "C" {
    pub fn memhash(buf: *const ::std::os::raw::c_char, n: usize) -> u64;
}
extern "C" {
    pub fn memhash_seed(buf: *const ::std::os::raw::c_char, n: usize, seed: u32) -> u64;
}
extern "C" {
    pub fn memhash32(buf: *const ::std::os::raw::c_char, n: usize) -> u32;
}
extern "C" {
    pub fn memhash32_seed(buf: *const ::std::os::raw::c_char, n: usize, seed: u32) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htable_t {
    pub size: usize,
    pub table: *mut *mut ::std::os::raw::c_void,
    pub _space: [*mut ::std::os::raw::c_void; 32usize],
}
#[test]
fn bindgen_test_layout_htable_t() {
    assert_eq!(
        ::std::mem::size_of::<htable_t>(),
        272usize,
        concat!("Size of: ", stringify!(htable_t))
    );
    assert_eq!(
        ::std::mem::align_of::<htable_t>(),
        8usize,
        concat!("Alignment of ", stringify!(htable_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<htable_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(htable_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<htable_t>())).table as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(htable_t),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<htable_t>()))._space as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(htable_t),
            "::",
            stringify!(_space)
        )
    );
}
extern "C" {
    pub fn htable_new(h: *mut htable_t, size: usize) -> *mut htable_t;
}
extern "C" {
    pub fn htable_free(h: *mut htable_t);
}
extern "C" {
    pub fn htable_reset(h: *mut htable_t, sz: usize);
}
extern "C" {
    pub fn ptrhash_get(
        h: *mut htable_t,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptrhash_put(
        h: *mut htable_t,
        key: *mut ::std::os::raw::c_void,
        val: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ptrhash_adjoin(
        h: *mut htable_t,
        key: *mut ::std::os::raw::c_void,
        val: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ptrhash_has(h: *mut htable_t, key: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptrhash_remove(
        h: *mut htable_t,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptrhash_bp(
        h: *mut htable_t,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bitvector_new(n: u64, initzero: ::std::os::raw::c_int) -> *mut u32;
}
extern "C" {
    pub fn bitvector_resize(
        b: *mut u32,
        oldsz: u64,
        newsz: u64,
        initzero: ::std::os::raw::c_int,
    ) -> *mut u32;
}
extern "C" {
    pub fn bitvector_nwords(nbits: u64) -> usize;
}
extern "C" {
    pub fn bitvector_set(b: *mut u32, n: u64, c: u32);
}
extern "C" {
    pub fn bitvector_get(b: *mut u32, n: u64) -> u32;
}
extern "C" {
    pub fn jl_strtod_c(
        nptr: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn jl_strtof_c(
        nptr: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn libsupport_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arraylist_t {
    pub len: usize,
    pub max: usize,
    pub items: *mut *mut ::std::os::raw::c_void,
    pub _space: [*mut ::std::os::raw::c_void; 29usize],
}
#[test]
fn bindgen_test_layout_arraylist_t() {
    assert_eq!(
        ::std::mem::size_of::<arraylist_t>(),
        256usize,
        concat!("Size of: ", stringify!(arraylist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<arraylist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(arraylist_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arraylist_t>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arraylist_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arraylist_t>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arraylist_t),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arraylist_t>())).items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arraylist_t),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arraylist_t>()))._space as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arraylist_t),
            "::",
            stringify!(_space)
        )
    );
}
extern "C" {
    pub fn arraylist_new(a: *mut arraylist_t, size: usize) -> *mut arraylist_t;
}
extern "C" {
    pub fn arraylist_free(a: *mut arraylist_t);
}
extern "C" {
    pub fn arraylist_push(a: *mut arraylist_t, elt: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn arraylist_pop(a: *mut arraylist_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn arraylist_grow(a: *mut arraylist_t, n: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__jmpbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__mask_was_saved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__saved_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn siglongjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type jl_taggedvalue_t = _jl_taggedvalue_t;
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
pub type __v4df = [f64; 4usize];
pub type __v8sf = [f32; 8usize];
pub type __v4di = [::std::os::raw::c_longlong; 4usize];
pub type __v8si = [::std::os::raw::c_int; 8usize];
pub type __v16hi = [::std::os::raw::c_short; 16usize];
pub type __v32qi = [::std::os::raw::c_char; 32usize];
pub type __v4du = [::std::os::raw::c_ulonglong; 4usize];
pub type __v8su = [::std::os::raw::c_uint; 8usize];
pub type __v16hu = [::std::os::raw::c_ushort; 16usize];
pub type __v32qu = [::std::os::raw::c_uchar; 32usize];
pub type __v32qs = [::std::os::raw::c_schar; 32usize];
pub type __m256 = [f32; 8usize];
pub type __m256d = [f64; 4usize];
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type __m256_u = [f32; 8usize];
pub type __m256d_u = [f64; 4usize];
pub type __m256i_u = [::std::os::raw::c_longlong; 4usize];
pub type __v64qi = [::std::os::raw::c_char; 64usize];
pub type __v32hi = [::std::os::raw::c_short; 32usize];
pub type __v8df = [f64; 8usize];
pub type __v16sf = [f32; 16usize];
pub type __v8di = [::std::os::raw::c_longlong; 8usize];
pub type __v16si = [::std::os::raw::c_int; 16usize];
pub type __v64qu = [::std::os::raw::c_uchar; 64usize];
pub type __v32hu = [::std::os::raw::c_ushort; 32usize];
pub type __v8du = [::std::os::raw::c_ulonglong; 8usize];
pub type __v16su = [::std::os::raw::c_uint; 16usize];
pub type __m512 = [f32; 16usize];
pub type __m512d = [f64; 8usize];
pub type __m512i = [::std::os::raw::c_longlong; 8usize];
pub type __m512_u = [f32; 16usize];
pub type __m512d_u = [f64; 8usize];
pub type __m512i_u = [::std::os::raw::c_longlong; 8usize];
pub type __mmask8 = ::std::os::raw::c_uchar;
pub type __mmask16 = ::std::os::raw::c_ushort;
pub const _MM_CMPINT_ENUM__MM_CMPINT_EQ: _MM_CMPINT_ENUM = 0;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LT: _MM_CMPINT_ENUM = 1;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LE: _MM_CMPINT_ENUM = 2;
pub const _MM_CMPINT_ENUM__MM_CMPINT_UNUSED: _MM_CMPINT_ENUM = 3;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NE: _MM_CMPINT_ENUM = 4;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLT: _MM_CMPINT_ENUM = 5;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLE: _MM_CMPINT_ENUM = 6;
pub type _MM_CMPINT_ENUM = u32;
pub const _MM_PERM_ENUM__MM_PERM_AAAA: _MM_PERM_ENUM = 0;
pub const _MM_PERM_ENUM__MM_PERM_AAAB: _MM_PERM_ENUM = 1;
pub const _MM_PERM_ENUM__MM_PERM_AAAC: _MM_PERM_ENUM = 2;
pub const _MM_PERM_ENUM__MM_PERM_AAAD: _MM_PERM_ENUM = 3;
pub const _MM_PERM_ENUM__MM_PERM_AABA: _MM_PERM_ENUM = 4;
pub const _MM_PERM_ENUM__MM_PERM_AABB: _MM_PERM_ENUM = 5;
pub const _MM_PERM_ENUM__MM_PERM_AABC: _MM_PERM_ENUM = 6;
pub const _MM_PERM_ENUM__MM_PERM_AABD: _MM_PERM_ENUM = 7;
pub const _MM_PERM_ENUM__MM_PERM_AACA: _MM_PERM_ENUM = 8;
pub const _MM_PERM_ENUM__MM_PERM_AACB: _MM_PERM_ENUM = 9;
pub const _MM_PERM_ENUM__MM_PERM_AACC: _MM_PERM_ENUM = 10;
pub const _MM_PERM_ENUM__MM_PERM_AACD: _MM_PERM_ENUM = 11;
pub const _MM_PERM_ENUM__MM_PERM_AADA: _MM_PERM_ENUM = 12;
pub const _MM_PERM_ENUM__MM_PERM_AADB: _MM_PERM_ENUM = 13;
pub const _MM_PERM_ENUM__MM_PERM_AADC: _MM_PERM_ENUM = 14;
pub const _MM_PERM_ENUM__MM_PERM_AADD: _MM_PERM_ENUM = 15;
pub const _MM_PERM_ENUM__MM_PERM_ABAA: _MM_PERM_ENUM = 16;
pub const _MM_PERM_ENUM__MM_PERM_ABAB: _MM_PERM_ENUM = 17;
pub const _MM_PERM_ENUM__MM_PERM_ABAC: _MM_PERM_ENUM = 18;
pub const _MM_PERM_ENUM__MM_PERM_ABAD: _MM_PERM_ENUM = 19;
pub const _MM_PERM_ENUM__MM_PERM_ABBA: _MM_PERM_ENUM = 20;
pub const _MM_PERM_ENUM__MM_PERM_ABBB: _MM_PERM_ENUM = 21;
pub const _MM_PERM_ENUM__MM_PERM_ABBC: _MM_PERM_ENUM = 22;
pub const _MM_PERM_ENUM__MM_PERM_ABBD: _MM_PERM_ENUM = 23;
pub const _MM_PERM_ENUM__MM_PERM_ABCA: _MM_PERM_ENUM = 24;
pub const _MM_PERM_ENUM__MM_PERM_ABCB: _MM_PERM_ENUM = 25;
pub const _MM_PERM_ENUM__MM_PERM_ABCC: _MM_PERM_ENUM = 26;
pub const _MM_PERM_ENUM__MM_PERM_ABCD: _MM_PERM_ENUM = 27;
pub const _MM_PERM_ENUM__MM_PERM_ABDA: _MM_PERM_ENUM = 28;
pub const _MM_PERM_ENUM__MM_PERM_ABDB: _MM_PERM_ENUM = 29;
pub const _MM_PERM_ENUM__MM_PERM_ABDC: _MM_PERM_ENUM = 30;
pub const _MM_PERM_ENUM__MM_PERM_ABDD: _MM_PERM_ENUM = 31;
pub const _MM_PERM_ENUM__MM_PERM_ACAA: _MM_PERM_ENUM = 32;
pub const _MM_PERM_ENUM__MM_PERM_ACAB: _MM_PERM_ENUM = 33;
pub const _MM_PERM_ENUM__MM_PERM_ACAC: _MM_PERM_ENUM = 34;
pub const _MM_PERM_ENUM__MM_PERM_ACAD: _MM_PERM_ENUM = 35;
pub const _MM_PERM_ENUM__MM_PERM_ACBA: _MM_PERM_ENUM = 36;
pub const _MM_PERM_ENUM__MM_PERM_ACBB: _MM_PERM_ENUM = 37;
pub const _MM_PERM_ENUM__MM_PERM_ACBC: _MM_PERM_ENUM = 38;
pub const _MM_PERM_ENUM__MM_PERM_ACBD: _MM_PERM_ENUM = 39;
pub const _MM_PERM_ENUM__MM_PERM_ACCA: _MM_PERM_ENUM = 40;
pub const _MM_PERM_ENUM__MM_PERM_ACCB: _MM_PERM_ENUM = 41;
pub const _MM_PERM_ENUM__MM_PERM_ACCC: _MM_PERM_ENUM = 42;
pub const _MM_PERM_ENUM__MM_PERM_ACCD: _MM_PERM_ENUM = 43;
pub const _MM_PERM_ENUM__MM_PERM_ACDA: _MM_PERM_ENUM = 44;
pub const _MM_PERM_ENUM__MM_PERM_ACDB: _MM_PERM_ENUM = 45;
pub const _MM_PERM_ENUM__MM_PERM_ACDC: _MM_PERM_ENUM = 46;
pub const _MM_PERM_ENUM__MM_PERM_ACDD: _MM_PERM_ENUM = 47;
pub const _MM_PERM_ENUM__MM_PERM_ADAA: _MM_PERM_ENUM = 48;
pub const _MM_PERM_ENUM__MM_PERM_ADAB: _MM_PERM_ENUM = 49;
pub const _MM_PERM_ENUM__MM_PERM_ADAC: _MM_PERM_ENUM = 50;
pub const _MM_PERM_ENUM__MM_PERM_ADAD: _MM_PERM_ENUM = 51;
pub const _MM_PERM_ENUM__MM_PERM_ADBA: _MM_PERM_ENUM = 52;
pub const _MM_PERM_ENUM__MM_PERM_ADBB: _MM_PERM_ENUM = 53;
pub const _MM_PERM_ENUM__MM_PERM_ADBC: _MM_PERM_ENUM = 54;
pub const _MM_PERM_ENUM__MM_PERM_ADBD: _MM_PERM_ENUM = 55;
pub const _MM_PERM_ENUM__MM_PERM_ADCA: _MM_PERM_ENUM = 56;
pub const _MM_PERM_ENUM__MM_PERM_ADCB: _MM_PERM_ENUM = 57;
pub const _MM_PERM_ENUM__MM_PERM_ADCC: _MM_PERM_ENUM = 58;
pub const _MM_PERM_ENUM__MM_PERM_ADCD: _MM_PERM_ENUM = 59;
pub const _MM_PERM_ENUM__MM_PERM_ADDA: _MM_PERM_ENUM = 60;
pub const _MM_PERM_ENUM__MM_PERM_ADDB: _MM_PERM_ENUM = 61;
pub const _MM_PERM_ENUM__MM_PERM_ADDC: _MM_PERM_ENUM = 62;
pub const _MM_PERM_ENUM__MM_PERM_ADDD: _MM_PERM_ENUM = 63;
pub const _MM_PERM_ENUM__MM_PERM_BAAA: _MM_PERM_ENUM = 64;
pub const _MM_PERM_ENUM__MM_PERM_BAAB: _MM_PERM_ENUM = 65;
pub const _MM_PERM_ENUM__MM_PERM_BAAC: _MM_PERM_ENUM = 66;
pub const _MM_PERM_ENUM__MM_PERM_BAAD: _MM_PERM_ENUM = 67;
pub const _MM_PERM_ENUM__MM_PERM_BABA: _MM_PERM_ENUM = 68;
pub const _MM_PERM_ENUM__MM_PERM_BABB: _MM_PERM_ENUM = 69;
pub const _MM_PERM_ENUM__MM_PERM_BABC: _MM_PERM_ENUM = 70;
pub const _MM_PERM_ENUM__MM_PERM_BABD: _MM_PERM_ENUM = 71;
pub const _MM_PERM_ENUM__MM_PERM_BACA: _MM_PERM_ENUM = 72;
pub const _MM_PERM_ENUM__MM_PERM_BACB: _MM_PERM_ENUM = 73;
pub const _MM_PERM_ENUM__MM_PERM_BACC: _MM_PERM_ENUM = 74;
pub const _MM_PERM_ENUM__MM_PERM_BACD: _MM_PERM_ENUM = 75;
pub const _MM_PERM_ENUM__MM_PERM_BADA: _MM_PERM_ENUM = 76;
pub const _MM_PERM_ENUM__MM_PERM_BADB: _MM_PERM_ENUM = 77;
pub const _MM_PERM_ENUM__MM_PERM_BADC: _MM_PERM_ENUM = 78;
pub const _MM_PERM_ENUM__MM_PERM_BADD: _MM_PERM_ENUM = 79;
pub const _MM_PERM_ENUM__MM_PERM_BBAA: _MM_PERM_ENUM = 80;
pub const _MM_PERM_ENUM__MM_PERM_BBAB: _MM_PERM_ENUM = 81;
pub const _MM_PERM_ENUM__MM_PERM_BBAC: _MM_PERM_ENUM = 82;
pub const _MM_PERM_ENUM__MM_PERM_BBAD: _MM_PERM_ENUM = 83;
pub const _MM_PERM_ENUM__MM_PERM_BBBA: _MM_PERM_ENUM = 84;
pub const _MM_PERM_ENUM__MM_PERM_BBBB: _MM_PERM_ENUM = 85;
pub const _MM_PERM_ENUM__MM_PERM_BBBC: _MM_PERM_ENUM = 86;
pub const _MM_PERM_ENUM__MM_PERM_BBBD: _MM_PERM_ENUM = 87;
pub const _MM_PERM_ENUM__MM_PERM_BBCA: _MM_PERM_ENUM = 88;
pub const _MM_PERM_ENUM__MM_PERM_BBCB: _MM_PERM_ENUM = 89;
pub const _MM_PERM_ENUM__MM_PERM_BBCC: _MM_PERM_ENUM = 90;
pub const _MM_PERM_ENUM__MM_PERM_BBCD: _MM_PERM_ENUM = 91;
pub const _MM_PERM_ENUM__MM_PERM_BBDA: _MM_PERM_ENUM = 92;
pub const _MM_PERM_ENUM__MM_PERM_BBDB: _MM_PERM_ENUM = 93;
pub const _MM_PERM_ENUM__MM_PERM_BBDC: _MM_PERM_ENUM = 94;
pub const _MM_PERM_ENUM__MM_PERM_BBDD: _MM_PERM_ENUM = 95;
pub const _MM_PERM_ENUM__MM_PERM_BCAA: _MM_PERM_ENUM = 96;
pub const _MM_PERM_ENUM__MM_PERM_BCAB: _MM_PERM_ENUM = 97;
pub const _MM_PERM_ENUM__MM_PERM_BCAC: _MM_PERM_ENUM = 98;
pub const _MM_PERM_ENUM__MM_PERM_BCAD: _MM_PERM_ENUM = 99;
pub const _MM_PERM_ENUM__MM_PERM_BCBA: _MM_PERM_ENUM = 100;
pub const _MM_PERM_ENUM__MM_PERM_BCBB: _MM_PERM_ENUM = 101;
pub const _MM_PERM_ENUM__MM_PERM_BCBC: _MM_PERM_ENUM = 102;
pub const _MM_PERM_ENUM__MM_PERM_BCBD: _MM_PERM_ENUM = 103;
pub const _MM_PERM_ENUM__MM_PERM_BCCA: _MM_PERM_ENUM = 104;
pub const _MM_PERM_ENUM__MM_PERM_BCCB: _MM_PERM_ENUM = 105;
pub const _MM_PERM_ENUM__MM_PERM_BCCC: _MM_PERM_ENUM = 106;
pub const _MM_PERM_ENUM__MM_PERM_BCCD: _MM_PERM_ENUM = 107;
pub const _MM_PERM_ENUM__MM_PERM_BCDA: _MM_PERM_ENUM = 108;
pub const _MM_PERM_ENUM__MM_PERM_BCDB: _MM_PERM_ENUM = 109;
pub const _MM_PERM_ENUM__MM_PERM_BCDC: _MM_PERM_ENUM = 110;
pub const _MM_PERM_ENUM__MM_PERM_BCDD: _MM_PERM_ENUM = 111;
pub const _MM_PERM_ENUM__MM_PERM_BDAA: _MM_PERM_ENUM = 112;
pub const _MM_PERM_ENUM__MM_PERM_BDAB: _MM_PERM_ENUM = 113;
pub const _MM_PERM_ENUM__MM_PERM_BDAC: _MM_PERM_ENUM = 114;
pub const _MM_PERM_ENUM__MM_PERM_BDAD: _MM_PERM_ENUM = 115;
pub const _MM_PERM_ENUM__MM_PERM_BDBA: _MM_PERM_ENUM = 116;
pub const _MM_PERM_ENUM__MM_PERM_BDBB: _MM_PERM_ENUM = 117;
pub const _MM_PERM_ENUM__MM_PERM_BDBC: _MM_PERM_ENUM = 118;
pub const _MM_PERM_ENUM__MM_PERM_BDBD: _MM_PERM_ENUM = 119;
pub const _MM_PERM_ENUM__MM_PERM_BDCA: _MM_PERM_ENUM = 120;
pub const _MM_PERM_ENUM__MM_PERM_BDCB: _MM_PERM_ENUM = 121;
pub const _MM_PERM_ENUM__MM_PERM_BDCC: _MM_PERM_ENUM = 122;
pub const _MM_PERM_ENUM__MM_PERM_BDCD: _MM_PERM_ENUM = 123;
pub const _MM_PERM_ENUM__MM_PERM_BDDA: _MM_PERM_ENUM = 124;
pub const _MM_PERM_ENUM__MM_PERM_BDDB: _MM_PERM_ENUM = 125;
pub const _MM_PERM_ENUM__MM_PERM_BDDC: _MM_PERM_ENUM = 126;
pub const _MM_PERM_ENUM__MM_PERM_BDDD: _MM_PERM_ENUM = 127;
pub const _MM_PERM_ENUM__MM_PERM_CAAA: _MM_PERM_ENUM = 128;
pub const _MM_PERM_ENUM__MM_PERM_CAAB: _MM_PERM_ENUM = 129;
pub const _MM_PERM_ENUM__MM_PERM_CAAC: _MM_PERM_ENUM = 130;
pub const _MM_PERM_ENUM__MM_PERM_CAAD: _MM_PERM_ENUM = 131;
pub const _MM_PERM_ENUM__MM_PERM_CABA: _MM_PERM_ENUM = 132;
pub const _MM_PERM_ENUM__MM_PERM_CABB: _MM_PERM_ENUM = 133;
pub const _MM_PERM_ENUM__MM_PERM_CABC: _MM_PERM_ENUM = 134;
pub const _MM_PERM_ENUM__MM_PERM_CABD: _MM_PERM_ENUM = 135;
pub const _MM_PERM_ENUM__MM_PERM_CACA: _MM_PERM_ENUM = 136;
pub const _MM_PERM_ENUM__MM_PERM_CACB: _MM_PERM_ENUM = 137;
pub const _MM_PERM_ENUM__MM_PERM_CACC: _MM_PERM_ENUM = 138;
pub const _MM_PERM_ENUM__MM_PERM_CACD: _MM_PERM_ENUM = 139;
pub const _MM_PERM_ENUM__MM_PERM_CADA: _MM_PERM_ENUM = 140;
pub const _MM_PERM_ENUM__MM_PERM_CADB: _MM_PERM_ENUM = 141;
pub const _MM_PERM_ENUM__MM_PERM_CADC: _MM_PERM_ENUM = 142;
pub const _MM_PERM_ENUM__MM_PERM_CADD: _MM_PERM_ENUM = 143;
pub const _MM_PERM_ENUM__MM_PERM_CBAA: _MM_PERM_ENUM = 144;
pub const _MM_PERM_ENUM__MM_PERM_CBAB: _MM_PERM_ENUM = 145;
pub const _MM_PERM_ENUM__MM_PERM_CBAC: _MM_PERM_ENUM = 146;
pub const _MM_PERM_ENUM__MM_PERM_CBAD: _MM_PERM_ENUM = 147;
pub const _MM_PERM_ENUM__MM_PERM_CBBA: _MM_PERM_ENUM = 148;
pub const _MM_PERM_ENUM__MM_PERM_CBBB: _MM_PERM_ENUM = 149;
pub const _MM_PERM_ENUM__MM_PERM_CBBC: _MM_PERM_ENUM = 150;
pub const _MM_PERM_ENUM__MM_PERM_CBBD: _MM_PERM_ENUM = 151;
pub const _MM_PERM_ENUM__MM_PERM_CBCA: _MM_PERM_ENUM = 152;
pub const _MM_PERM_ENUM__MM_PERM_CBCB: _MM_PERM_ENUM = 153;
pub const _MM_PERM_ENUM__MM_PERM_CBCC: _MM_PERM_ENUM = 154;
pub const _MM_PERM_ENUM__MM_PERM_CBCD: _MM_PERM_ENUM = 155;
pub const _MM_PERM_ENUM__MM_PERM_CBDA: _MM_PERM_ENUM = 156;
pub const _MM_PERM_ENUM__MM_PERM_CBDB: _MM_PERM_ENUM = 157;
pub const _MM_PERM_ENUM__MM_PERM_CBDC: _MM_PERM_ENUM = 158;
pub const _MM_PERM_ENUM__MM_PERM_CBDD: _MM_PERM_ENUM = 159;
pub const _MM_PERM_ENUM__MM_PERM_CCAA: _MM_PERM_ENUM = 160;
pub const _MM_PERM_ENUM__MM_PERM_CCAB: _MM_PERM_ENUM = 161;
pub const _MM_PERM_ENUM__MM_PERM_CCAC: _MM_PERM_ENUM = 162;
pub const _MM_PERM_ENUM__MM_PERM_CCAD: _MM_PERM_ENUM = 163;
pub const _MM_PERM_ENUM__MM_PERM_CCBA: _MM_PERM_ENUM = 164;
pub const _MM_PERM_ENUM__MM_PERM_CCBB: _MM_PERM_ENUM = 165;
pub const _MM_PERM_ENUM__MM_PERM_CCBC: _MM_PERM_ENUM = 166;
pub const _MM_PERM_ENUM__MM_PERM_CCBD: _MM_PERM_ENUM = 167;
pub const _MM_PERM_ENUM__MM_PERM_CCCA: _MM_PERM_ENUM = 168;
pub const _MM_PERM_ENUM__MM_PERM_CCCB: _MM_PERM_ENUM = 169;
pub const _MM_PERM_ENUM__MM_PERM_CCCC: _MM_PERM_ENUM = 170;
pub const _MM_PERM_ENUM__MM_PERM_CCCD: _MM_PERM_ENUM = 171;
pub const _MM_PERM_ENUM__MM_PERM_CCDA: _MM_PERM_ENUM = 172;
pub const _MM_PERM_ENUM__MM_PERM_CCDB: _MM_PERM_ENUM = 173;
pub const _MM_PERM_ENUM__MM_PERM_CCDC: _MM_PERM_ENUM = 174;
pub const _MM_PERM_ENUM__MM_PERM_CCDD: _MM_PERM_ENUM = 175;
pub const _MM_PERM_ENUM__MM_PERM_CDAA: _MM_PERM_ENUM = 176;
pub const _MM_PERM_ENUM__MM_PERM_CDAB: _MM_PERM_ENUM = 177;
pub const _MM_PERM_ENUM__MM_PERM_CDAC: _MM_PERM_ENUM = 178;
pub const _MM_PERM_ENUM__MM_PERM_CDAD: _MM_PERM_ENUM = 179;
pub const _MM_PERM_ENUM__MM_PERM_CDBA: _MM_PERM_ENUM = 180;
pub const _MM_PERM_ENUM__MM_PERM_CDBB: _MM_PERM_ENUM = 181;
pub const _MM_PERM_ENUM__MM_PERM_CDBC: _MM_PERM_ENUM = 182;
pub const _MM_PERM_ENUM__MM_PERM_CDBD: _MM_PERM_ENUM = 183;
pub const _MM_PERM_ENUM__MM_PERM_CDCA: _MM_PERM_ENUM = 184;
pub const _MM_PERM_ENUM__MM_PERM_CDCB: _MM_PERM_ENUM = 185;
pub const _MM_PERM_ENUM__MM_PERM_CDCC: _MM_PERM_ENUM = 186;
pub const _MM_PERM_ENUM__MM_PERM_CDCD: _MM_PERM_ENUM = 187;
pub const _MM_PERM_ENUM__MM_PERM_CDDA: _MM_PERM_ENUM = 188;
pub const _MM_PERM_ENUM__MM_PERM_CDDB: _MM_PERM_ENUM = 189;
pub const _MM_PERM_ENUM__MM_PERM_CDDC: _MM_PERM_ENUM = 190;
pub const _MM_PERM_ENUM__MM_PERM_CDDD: _MM_PERM_ENUM = 191;
pub const _MM_PERM_ENUM__MM_PERM_DAAA: _MM_PERM_ENUM = 192;
pub const _MM_PERM_ENUM__MM_PERM_DAAB: _MM_PERM_ENUM = 193;
pub const _MM_PERM_ENUM__MM_PERM_DAAC: _MM_PERM_ENUM = 194;
pub const _MM_PERM_ENUM__MM_PERM_DAAD: _MM_PERM_ENUM = 195;
pub const _MM_PERM_ENUM__MM_PERM_DABA: _MM_PERM_ENUM = 196;
pub const _MM_PERM_ENUM__MM_PERM_DABB: _MM_PERM_ENUM = 197;
pub const _MM_PERM_ENUM__MM_PERM_DABC: _MM_PERM_ENUM = 198;
pub const _MM_PERM_ENUM__MM_PERM_DABD: _MM_PERM_ENUM = 199;
pub const _MM_PERM_ENUM__MM_PERM_DACA: _MM_PERM_ENUM = 200;
pub const _MM_PERM_ENUM__MM_PERM_DACB: _MM_PERM_ENUM = 201;
pub const _MM_PERM_ENUM__MM_PERM_DACC: _MM_PERM_ENUM = 202;
pub const _MM_PERM_ENUM__MM_PERM_DACD: _MM_PERM_ENUM = 203;
pub const _MM_PERM_ENUM__MM_PERM_DADA: _MM_PERM_ENUM = 204;
pub const _MM_PERM_ENUM__MM_PERM_DADB: _MM_PERM_ENUM = 205;
pub const _MM_PERM_ENUM__MM_PERM_DADC: _MM_PERM_ENUM = 206;
pub const _MM_PERM_ENUM__MM_PERM_DADD: _MM_PERM_ENUM = 207;
pub const _MM_PERM_ENUM__MM_PERM_DBAA: _MM_PERM_ENUM = 208;
pub const _MM_PERM_ENUM__MM_PERM_DBAB: _MM_PERM_ENUM = 209;
pub const _MM_PERM_ENUM__MM_PERM_DBAC: _MM_PERM_ENUM = 210;
pub const _MM_PERM_ENUM__MM_PERM_DBAD: _MM_PERM_ENUM = 211;
pub const _MM_PERM_ENUM__MM_PERM_DBBA: _MM_PERM_ENUM = 212;
pub const _MM_PERM_ENUM__MM_PERM_DBBB: _MM_PERM_ENUM = 213;
pub const _MM_PERM_ENUM__MM_PERM_DBBC: _MM_PERM_ENUM = 214;
pub const _MM_PERM_ENUM__MM_PERM_DBBD: _MM_PERM_ENUM = 215;
pub const _MM_PERM_ENUM__MM_PERM_DBCA: _MM_PERM_ENUM = 216;
pub const _MM_PERM_ENUM__MM_PERM_DBCB: _MM_PERM_ENUM = 217;
pub const _MM_PERM_ENUM__MM_PERM_DBCC: _MM_PERM_ENUM = 218;
pub const _MM_PERM_ENUM__MM_PERM_DBCD: _MM_PERM_ENUM = 219;
pub const _MM_PERM_ENUM__MM_PERM_DBDA: _MM_PERM_ENUM = 220;
pub const _MM_PERM_ENUM__MM_PERM_DBDB: _MM_PERM_ENUM = 221;
pub const _MM_PERM_ENUM__MM_PERM_DBDC: _MM_PERM_ENUM = 222;
pub const _MM_PERM_ENUM__MM_PERM_DBDD: _MM_PERM_ENUM = 223;
pub const _MM_PERM_ENUM__MM_PERM_DCAA: _MM_PERM_ENUM = 224;
pub const _MM_PERM_ENUM__MM_PERM_DCAB: _MM_PERM_ENUM = 225;
pub const _MM_PERM_ENUM__MM_PERM_DCAC: _MM_PERM_ENUM = 226;
pub const _MM_PERM_ENUM__MM_PERM_DCAD: _MM_PERM_ENUM = 227;
pub const _MM_PERM_ENUM__MM_PERM_DCBA: _MM_PERM_ENUM = 228;
pub const _MM_PERM_ENUM__MM_PERM_DCBB: _MM_PERM_ENUM = 229;
pub const _MM_PERM_ENUM__MM_PERM_DCBC: _MM_PERM_ENUM = 230;
pub const _MM_PERM_ENUM__MM_PERM_DCBD: _MM_PERM_ENUM = 231;
pub const _MM_PERM_ENUM__MM_PERM_DCCA: _MM_PERM_ENUM = 232;
pub const _MM_PERM_ENUM__MM_PERM_DCCB: _MM_PERM_ENUM = 233;
pub const _MM_PERM_ENUM__MM_PERM_DCCC: _MM_PERM_ENUM = 234;
pub const _MM_PERM_ENUM__MM_PERM_DCCD: _MM_PERM_ENUM = 235;
pub const _MM_PERM_ENUM__MM_PERM_DCDA: _MM_PERM_ENUM = 236;
pub const _MM_PERM_ENUM__MM_PERM_DCDB: _MM_PERM_ENUM = 237;
pub const _MM_PERM_ENUM__MM_PERM_DCDC: _MM_PERM_ENUM = 238;
pub const _MM_PERM_ENUM__MM_PERM_DCDD: _MM_PERM_ENUM = 239;
pub const _MM_PERM_ENUM__MM_PERM_DDAA: _MM_PERM_ENUM = 240;
pub const _MM_PERM_ENUM__MM_PERM_DDAB: _MM_PERM_ENUM = 241;
pub const _MM_PERM_ENUM__MM_PERM_DDAC: _MM_PERM_ENUM = 242;
pub const _MM_PERM_ENUM__MM_PERM_DDAD: _MM_PERM_ENUM = 243;
pub const _MM_PERM_ENUM__MM_PERM_DDBA: _MM_PERM_ENUM = 244;
pub const _MM_PERM_ENUM__MM_PERM_DDBB: _MM_PERM_ENUM = 245;
pub const _MM_PERM_ENUM__MM_PERM_DDBC: _MM_PERM_ENUM = 246;
pub const _MM_PERM_ENUM__MM_PERM_DDBD: _MM_PERM_ENUM = 247;
pub const _MM_PERM_ENUM__MM_PERM_DDCA: _MM_PERM_ENUM = 248;
pub const _MM_PERM_ENUM__MM_PERM_DDCB: _MM_PERM_ENUM = 249;
pub const _MM_PERM_ENUM__MM_PERM_DDCC: _MM_PERM_ENUM = 250;
pub const _MM_PERM_ENUM__MM_PERM_DDCD: _MM_PERM_ENUM = 251;
pub const _MM_PERM_ENUM__MM_PERM_DDDA: _MM_PERM_ENUM = 252;
pub const _MM_PERM_ENUM__MM_PERM_DDDB: _MM_PERM_ENUM = 253;
pub const _MM_PERM_ENUM__MM_PERM_DDDC: _MM_PERM_ENUM = 254;
pub const _MM_PERM_ENUM__MM_PERM_DDDD: _MM_PERM_ENUM = 255;
pub type _MM_PERM_ENUM = u32;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_1_2: _MM_MANTISSA_NORM_ENUM = 0;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_2: _MM_MANTISSA_NORM_ENUM = 1;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_1: _MM_MANTISSA_NORM_ENUM = 2;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p75_1p5: _MM_MANTISSA_NORM_ENUM = 3;
pub type _MM_MANTISSA_NORM_ENUM = u32;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_src: _MM_MANTISSA_SIGN_ENUM = 0;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_zero: _MM_MANTISSA_SIGN_ENUM = 1;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_nan: _MM_MANTISSA_SIGN_ENUM = 2;
pub type _MM_MANTISSA_SIGN_ENUM = u32;
pub type __v2hi = [::std::os::raw::c_short; 2usize];
pub type __v4qi = [::std::os::raw::c_char; 4usize];
pub type __v2qi = [::std::os::raw::c_char; 2usize];
pub type __mmask32 = ::std::os::raw::c_uint;
pub type __mmask64 = ::std::os::raw::c_ulonglong;
pub type __m512bh = [::std::os::raw::c_short; 32usize];
pub type __m256bh = [::std::os::raw::c_short; 16usize];
pub type __bfloat16 = ::std::os::raw::c_ushort;
pub type __m128bh = [::std::os::raw::c_short; 8usize];
pub type jl_tls_states_t = _jl_tls_states_t;
pub type jl_ptls_t = *mut jl_tls_states_t;
extern "C" {
    pub fn jl_threadid() -> i16;
}
extern "C" {
    pub fn jl_threading_profile();
}
extern "C" {
    pub fn jl_get_ptls_states() -> jl_ptls_t;
}
pub type jl_get_ptls_states_func = ::std::option::Option<unsafe extern "C" fn() -> jl_ptls_t>;
extern "C" {
    pub fn jl_set_ptls_states_getter(f: jl_get_ptls_states_func);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_ucontext_t {
    pub uc_mcontext: sigjmp_buf,
}
#[test]
fn bindgen_test_layout_jl_ucontext_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_ucontext_t>(),
        200usize,
        concat!("Size of: ", stringify!(jl_ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_ucontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_ucontext_t>())).uc_mcontext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_mutex_t {
    pub owner: ::std::os::raw::c_ulong,
    pub count: u32,
}
#[test]
fn bindgen_test_layout_jl_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_mutex_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_mutex_t>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_mutex_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_mutex_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_mutex_t),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_gc_pool_t {
    pub freelist: *mut jl_taggedvalue_t,
    pub newpages: *mut jl_taggedvalue_t,
    pub osize: u16,
}
#[test]
fn bindgen_test_layout_jl_gc_pool_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_gc_pool_t>(),
        24usize,
        concat!("Size of: ", stringify!(jl_gc_pool_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_gc_pool_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_gc_pool_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_pool_t>())).freelist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_pool_t),
            "::",
            stringify!(freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_pool_t>())).newpages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_pool_t),
            "::",
            stringify!(newpages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_pool_t>())).osize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_pool_t),
            "::",
            stringify!(osize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_thread_gc_num_t {
    pub allocd: i64,
    pub freed: i64,
    pub malloc: u64,
    pub realloc: u64,
    pub poolalloc: u64,
    pub bigalloc: u64,
    pub freecall: u64,
}
#[test]
fn bindgen_test_layout_jl_thread_gc_num_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_thread_gc_num_t>(),
        56usize,
        concat!("Size of: ", stringify!(jl_thread_gc_num_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_thread_gc_num_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_thread_gc_num_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_gc_num_t>())).allocd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_gc_num_t),
            "::",
            stringify!(allocd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_gc_num_t>())).freed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_gc_num_t),
            "::",
            stringify!(freed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_gc_num_t>())).malloc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_gc_num_t),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_gc_num_t>())).realloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_gc_num_t),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_gc_num_t>())).poolalloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_gc_num_t),
            "::",
            stringify!(poolalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_gc_num_t>())).bigalloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_gc_num_t),
            "::",
            stringify!(bigalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_gc_num_t>())).freecall as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_gc_num_t),
            "::",
            stringify!(freecall)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct jl_thread_heap_t {
    pub weak_refs: arraylist_t,
    pub live_tasks: arraylist_t,
    pub mallocarrays: *mut _mallocarray_t,
    pub mafreelist: *mut _mallocarray_t,
    pub big_objects: *mut _bigval_t,
    pub rem_bindings: arraylist_t,
    pub _remset: [arraylist_t; 2usize],
    pub remset_nptr: ::std::os::raw::c_int,
    pub remset: *mut arraylist_t,
    pub last_remset: *mut arraylist_t,
    pub norm_pools: [jl_gc_pool_t; 41usize],
    pub free_stacks: [arraylist_t; 16usize],
}
#[test]
fn bindgen_test_layout_jl_thread_heap_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_thread_heap_t>(),
        6408usize,
        concat!("Size of: ", stringify!(jl_thread_heap_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_thread_heap_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_thread_heap_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).weak_refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(weak_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).live_tasks as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(live_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).mallocarrays as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(mallocarrays)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).mafreelist as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(mafreelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).big_objects as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(big_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).rem_bindings as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(rem_bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>()))._remset as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(_remset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).remset_nptr as *const _ as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(remset_nptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).remset as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(remset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).last_remset as *const _ as usize },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(last_remset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).norm_pools as *const _ as usize },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(norm_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).free_stacks as *const _ as usize },
        2312usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(free_stacks)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_gc_mark_data {
    _unused: [u8; 0],
}
pub type jl_gc_mark_data_t = _jl_gc_mark_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_gc_mark_sp_t {
    pub pc: *mut *mut ::std::os::raw::c_void,
    pub data: *mut jl_gc_mark_data_t,
    pub pc_start: *mut *mut ::std::os::raw::c_void,
    pub pc_end: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_jl_gc_mark_sp_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_gc_mark_sp_t>(),
        32usize,
        concat!("Size of: ", stringify!(jl_gc_mark_sp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_gc_mark_sp_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_gc_mark_sp_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_sp_t>())).pc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_sp_t),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_sp_t>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_sp_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_sp_t>())).pc_start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_sp_t),
            "::",
            stringify!(pc_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_sp_t>())).pc_end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_sp_t),
            "::",
            stringify!(pc_end)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct jl_gc_mark_cache_t {
    pub perm_scanned_bytes: usize,
    pub scanned_bytes: usize,
    pub nbig_obj: usize,
    pub big_obj: [*mut ::std::os::raw::c_void; 1024usize],
    pub stack_lock: jl_mutex_t,
    pub pc_stack: *mut *mut ::std::os::raw::c_void,
    pub pc_stack_end: *mut *mut ::std::os::raw::c_void,
    pub data_stack: *mut jl_gc_mark_data_t,
}
#[test]
fn bindgen_test_layout_jl_gc_mark_cache_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_gc_mark_cache_t>(),
        8256usize,
        concat!("Size of: ", stringify!(jl_gc_mark_cache_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_gc_mark_cache_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_gc_mark_cache_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).perm_scanned_bytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(perm_scanned_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).scanned_bytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(scanned_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).nbig_obj as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(nbig_obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).big_obj as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(big_obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).stack_lock as *const _ as usize },
        8216usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(stack_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).pc_stack as *const _ as usize },
        8232usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(pc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).pc_stack_end as *const _ as usize },
        8240usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(pc_stack_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).data_stack as *const _ as usize },
        8248usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(data_stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_bt_element_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_tls_states_t {
    pub pgcstack: *mut _jl_gcframe_t,
    pub world_age: usize,
    pub tid: i16,
    pub rngseed: u64,
    pub safepoint: *mut usize,
    pub sleep_check_state: i8,
    pub gc_state: i8,
    pub in_finalizer: i8,
    pub disable_gc: i8,
    pub heap: jl_thread_heap_t,
    pub gc_num: jl_thread_gc_num_t,
    pub sleep_lock: uv_mutex_t,
    pub wake_signal: uv_cond_t,
    pub defer_signal: sig_atomic_t,
    pub current_task: *mut _jl_task_t,
    pub root_task: *mut _jl_task_t,
    pub stackbase: *mut ::std::os::raw::c_void,
    pub stacksize: usize,
    pub base_ctx: jl_ucontext_t,
    pub safe_restore: *mut sigjmp_buf,
    pub sig_exception: *mut _jl_value_t,
    pub bt_data: *mut _jl_bt_element_t,
    pub bt_size: usize,
    pub signal_request: sig_atomic_t,
    pub io_wait: sig_atomic_t,
    pub signal_stack: *mut ::std::os::raw::c_void,
    pub system_id: ::std::os::raw::c_ulong,
    pub in_pure_callback: ::std::os::raw::c_int,
    pub finalizers_inhibited: ::std::os::raw::c_int,
    pub finalizers: arraylist_t,
    pub gc_cache: jl_gc_mark_cache_t,
    pub sweep_objs: arraylist_t,
    pub gc_mark_sp: jl_gc_mark_sp_t,
    pub previous_exception: *mut _jl_value_t,
}
#[test]
fn bindgen_test_layout__jl_tls_states_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_tls_states_t>(),
        15712usize,
        concat!("Size of: ", stringify!(_jl_tls_states_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_tls_states_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_tls_states_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).pgcstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(pgcstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).world_age as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(world_age)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).tid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).rngseed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(rngseed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).safepoint as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(safepoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_tls_states_t>())).sleep_check_state as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(sleep_check_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).gc_state as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(gc_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).in_finalizer as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(in_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).disable_gc as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(disable_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).heap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).gc_num as *const _ as usize },
        6456usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(gc_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).sleep_lock as *const _ as usize },
        6512usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(sleep_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).wake_signal as *const _ as usize },
        6552usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(wake_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).defer_signal as *const _ as usize },
        6600usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(defer_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).current_task as *const _ as usize },
        6608usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(current_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).root_task as *const _ as usize },
        6616usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(root_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).stackbase as *const _ as usize },
        6624usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(stackbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).stacksize as *const _ as usize },
        6632usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).base_ctx as *const _ as usize },
        6640usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(base_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).safe_restore as *const _ as usize },
        6840usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(safe_restore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).sig_exception as *const _ as usize },
        6848usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(sig_exception)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).bt_data as *const _ as usize },
        6856usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(bt_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).bt_size as *const _ as usize },
        6864usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(bt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).signal_request as *const _ as usize },
        6872usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(signal_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).io_wait as *const _ as usize },
        6876usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(io_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).signal_stack as *const _ as usize },
        6880usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(signal_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).system_id as *const _ as usize },
        6888usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(system_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_tls_states_t>())).in_pure_callback as *const _ as usize
        },
        6896usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(in_pure_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_tls_states_t>())).finalizers_inhibited as *const _ as usize
        },
        6900usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(finalizers_inhibited)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).finalizers as *const _ as usize },
        6904usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(finalizers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).gc_cache as *const _ as usize },
        7160usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(gc_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).sweep_objs as *const _ as usize },
        15416usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(sweep_objs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).gc_mark_sp as *const _ as usize },
        15672usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(gc_mark_sp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_tls_states_t>())).previous_exception as *const _ as usize
        },
        15704usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(previous_exception)
        )
    );
}
extern "C" {
    pub fn jl_cpu_pause();
}
extern "C" {
    pub fn jl_cpu_wake();
}
extern "C" {
    pub fn jl_gc_safepoint();
}
extern "C" {
    pub fn jl_gc_enable_finalizers(ptls: jl_ptls_t, on: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_wakeup_thread(tid: i16);
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
pub type jl_value_t = _jl_value_t;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _jl_taggedvalue_bits {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout__jl_taggedvalue_bits() {
    assert_eq!(
        ::std::mem::size_of::<_jl_taggedvalue_bits>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_taggedvalue_bits))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_taggedvalue_bits>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_taggedvalue_bits))
    );
}
impl _jl_taggedvalue_bits {
    #[inline]
    pub fn gc(&self) -> usize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_gc(&mut self, val: usize) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gc: usize) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let gc: u64 = unsafe { ::std::mem::transmute(gc) };
            gc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_taggedvalue_t {
    pub __bindgen_anon_1: _jl_taggedvalue_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _jl_taggedvalue_t__bindgen_ty_1 {
    pub header: usize,
    pub next: *mut jl_taggedvalue_t,
    pub type_: *mut jl_value_t,
    pub bits: _jl_taggedvalue_bits,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__jl_taggedvalue_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_jl_taggedvalue_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_taggedvalue_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_taggedvalue_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_taggedvalue_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_taggedvalue_t__bindgen_ty_1>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_taggedvalue_t__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_taggedvalue_t__bindgen_ty_1>())).next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_taggedvalue_t__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_taggedvalue_t__bindgen_ty_1>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_taggedvalue_t__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_taggedvalue_t__bindgen_ty_1>())).bits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_taggedvalue_t__bindgen_ty_1),
            "::",
            stringify!(bits)
        )
    );
}
#[test]
fn bindgen_test_layout__jl_taggedvalue_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_taggedvalue_t>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_taggedvalue_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_taggedvalue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_taggedvalue_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_sym_t {
    pub left: *mut _jl_sym_t,
    pub right: *mut _jl_sym_t,
    pub hash: usize,
}
#[test]
fn bindgen_test_layout__jl_sym_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_sym_t>(),
        24usize,
        concat!("Size of: ", stringify!(_jl_sym_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_sym_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_sym_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_sym_t>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_sym_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_sym_t>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_sym_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_sym_t>())).hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_sym_t),
            "::",
            stringify!(hash)
        )
    );
}
pub type jl_sym_t = _jl_sym_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_ssavalue_t {
    pub id: isize,
}
#[test]
fn bindgen_test_layout__jl_ssavalue_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_ssavalue_t>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_ssavalue_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_ssavalue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_ssavalue_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_ssavalue_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_ssavalue_t),
            "::",
            stringify!(id)
        )
    );
}
pub type jl_ssavalue_t = _jl_ssavalue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_svec_t {
    pub length: usize,
}
#[test]
fn bindgen_test_layout_jl_svec_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_svec_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_svec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_svec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_svec_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_svec_t>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_svec_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct jl_array_flags_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_jl_array_flags_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_array_flags_t>(),
        2usize,
        concat!("Size of: ", stringify!(jl_array_flags_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_array_flags_t>(),
        2usize,
        concat!("Alignment of ", stringify!(jl_array_flags_t))
    );
}
impl jl_array_flags_t {
    #[inline]
    pub fn how(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_how(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ndims(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_ndims(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn pooled(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_pooled(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ptrarray(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ptrarray(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasptr(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hasptr(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isshared(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_isshared(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isaligned(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_isaligned(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        how: u16,
        ndims: u16,
        pooled: u16,
        ptrarray: u16,
        hasptr: u16,
        isshared: u16,
        isaligned: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let how: u16 = unsafe { ::std::mem::transmute(how) };
            how as u64
        });
        __bindgen_bitfield_unit.set(2usize, 9u8, {
            let ndims: u16 = unsafe { ::std::mem::transmute(ndims) };
            ndims as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let pooled: u16 = unsafe { ::std::mem::transmute(pooled) };
            pooled as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ptrarray: u16 = unsafe { ::std::mem::transmute(ptrarray) };
            ptrarray as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hasptr: u16 = unsafe { ::std::mem::transmute(hasptr) };
            hasptr as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let isshared: u16 = unsafe { ::std::mem::transmute(isshared) };
            isshared as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let isaligned: u16 = unsafe { ::std::mem::transmute(isaligned) };
            isaligned as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct jl_array_t {
    pub data: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub flags: jl_array_flags_t,
    pub elsize: u16,
    pub offset: u32,
    pub nrows: usize,
    pub __bindgen_anon_1: jl_array_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union jl_array_t__bindgen_ty_1 {
    pub maxsize: usize,
    pub ncols: usize,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_jl_array_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<jl_array_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(jl_array_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_array_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_array_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_array_t__bindgen_ty_1>())).maxsize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t__bindgen_ty_1),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t__bindgen_ty_1>())).ncols as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t__bindgen_ty_1),
            "::",
            stringify!(ncols)
        )
    );
}
#[test]
fn bindgen_test_layout_jl_array_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_array_t>(),
        40usize,
        concat!("Size of: ", stringify!(jl_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_array_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).elsize as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(elsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).offset as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).nrows as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(nrows)
        )
    );
}
pub type jl_tupletype_t = _jl_datatype_t;
pub type jl_typemap_t = jl_value_t;
pub type jl_call_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut jl_value_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
        arg4: *mut _jl_code_instance_t,
    ) -> *mut jl_value_t,
>;
pub type jl_callptr_t = jl_call_t;
extern "C" {
    pub fn jl_fptr_args(
        arg1: *mut jl_value_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
        arg4: *mut _jl_code_instance_t,
    ) -> *mut jl_value_t;
}
pub type jl_fptr_args_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut jl_value_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
    ) -> *mut jl_value_t,
>;
extern "C" {
    pub fn jl_fptr_const_return(
        arg1: *mut jl_value_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
        arg4: *mut _jl_code_instance_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_fptr_sparam(
        arg1: *mut jl_value_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
        arg4: *mut _jl_code_instance_t,
    ) -> *mut jl_value_t;
}
pub type jl_fptr_sparam_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut jl_value_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
        arg4: *mut jl_svec_t,
    ) -> *mut jl_value_t,
>;
extern "C" {
    pub fn jl_fptr_interpret_call(
        arg1: *mut jl_value_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
        arg4: *mut _jl_code_instance_t,
    ) -> *mut jl_value_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union jl_generic_specptr_t {
    pub fptr: *mut ::std::os::raw::c_void,
    pub fptr1: jl_fptr_args_t,
    pub fptr3: jl_fptr_sparam_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_jl_generic_specptr_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_generic_specptr_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_generic_specptr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_generic_specptr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_generic_specptr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_generic_specptr_t>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_generic_specptr_t),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_generic_specptr_t>())).fptr1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_generic_specptr_t),
            "::",
            stringify!(fptr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_generic_specptr_t>())).fptr3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_generic_specptr_t),
            "::",
            stringify!(fptr3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_llvm_functions_t {
    pub functionObject: *const ::std::os::raw::c_char,
    pub specFunctionObject: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__jl_llvm_functions_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_llvm_functions_t>(),
        16usize,
        concat!("Size of: ", stringify!(_jl_llvm_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_llvm_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_llvm_functions_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_llvm_functions_t>())).functionObject as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_llvm_functions_t),
            "::",
            stringify!(functionObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_llvm_functions_t>())).specFunctionObject as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_llvm_functions_t),
            "::",
            stringify!(specFunctionObject)
        )
    );
}
pub type jl_llvm_functions_t = _jl_llvm_functions_t;
pub type jl_method_instance_t = _jl_method_instance_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_line_info_node_t {
    pub method: *mut jl_value_t,
    pub file: *mut jl_sym_t,
    pub line: isize,
    pub inlined_at: isize,
}
#[test]
fn bindgen_test_layout__jl_line_info_node_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_line_info_node_t>(),
        32usize,
        concat!("Size of: ", stringify!(_jl_line_info_node_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_line_info_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_line_info_node_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_line_info_node_t>())).method as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_line_info_node_t),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_line_info_node_t>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_line_info_node_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_line_info_node_t>())).line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_line_info_node_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_line_info_node_t>())).inlined_at as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_line_info_node_t),
            "::",
            stringify!(inlined_at)
        )
    );
}
pub type jl_line_info_node_t = _jl_line_info_node_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_code_info_t {
    pub code: *mut jl_array_t,
    pub codelocs: *mut jl_value_t,
    pub ssavaluetypes: *mut jl_value_t,
    pub ssaflags: *mut jl_array_t,
    pub method_for_inference_limit_heuristics: *mut jl_value_t,
    pub linetable: *mut jl_value_t,
    pub slotnames: *mut jl_array_t,
    pub slotflags: *mut jl_array_t,
    pub slottypes: *mut jl_value_t,
    pub rettype: *mut jl_value_t,
    pub parent: *mut jl_method_instance_t,
    pub edges: *mut jl_value_t,
    pub min_world: usize,
    pub max_world: usize,
    pub inferred: u8,
    pub inlineable: u8,
    pub propagate_inbounds: u8,
    pub pure_: u8,
}
#[test]
fn bindgen_test_layout__jl_code_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_code_info_t>(),
        120usize,
        concat!("Size of: ", stringify!(_jl_code_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_code_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_code_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).codelocs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(codelocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).ssavaluetypes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(ssavaluetypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).ssaflags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(ssaflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_code_info_t>())).method_for_inference_limit_heuristics
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(method_for_inference_limit_heuristics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).linetable as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(linetable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).slotnames as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(slotnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).slotflags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(slotflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).slottypes as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(slottypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).rettype as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(rettype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).parent as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).edges as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(edges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).min_world as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(min_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).max_world as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(max_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).inferred as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(inferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).inlineable as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(inlineable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_code_info_t>())).propagate_inbounds as *const _ as usize
        },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(propagate_inbounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).pure_ as *const _ as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(pure_)
        )
    );
}
pub type jl_code_info_t = _jl_code_info_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_method_t {
    pub name: *mut jl_sym_t,
    pub module: *mut _jl_module_t,
    pub file: *mut jl_sym_t,
    pub line: i32,
    pub primary_world: usize,
    pub deleted_world: usize,
    pub sig: *mut jl_value_t,
    pub ambig: *mut jl_value_t,
    pub resorted: *mut jl_value_t,
    pub specializations: *mut jl_typemap_t,
    pub slot_syms: *mut jl_value_t,
    pub source: *mut jl_value_t,
    pub unspecialized: *mut _jl_method_instance_t,
    pub generator: *mut jl_value_t,
    pub roots: *mut jl_array_t,
    pub invokes: *mut jl_typemap_t,
    pub nargs: i32,
    pub called: i32,
    pub nospecialize: i32,
    pub nkw: i32,
    pub isva: u8,
    pub pure_: u8,
    pub writelock: jl_mutex_t,
}
#[test]
fn bindgen_test_layout__jl_method_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_method_t>(),
        168usize,
        concat!("Size of: ", stringify!(_jl_method_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_method_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_method_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).module as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).file as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).line as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).primary_world as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(primary_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).deleted_world as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(deleted_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).sig as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).ambig as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(ambig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).resorted as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(resorted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).specializations as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(specializations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).slot_syms as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(slot_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).source as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).unspecialized as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(unspecialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).generator as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(generator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).roots as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(roots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).invokes as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(invokes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).nargs as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(nargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).called as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(called)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).nospecialize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(nospecialize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).nkw as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(nkw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).isva as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(isva)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).pure_ as *const _ as usize },
        145usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(pure_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).writelock as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(writelock)
        )
    );
}
pub type jl_method_t = _jl_method_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_method_instance_t {
    pub def: _jl_method_instance_t__bindgen_ty_1,
    pub specTypes: *mut jl_value_t,
    pub sparam_vals: *mut jl_svec_t,
    pub uninferred: *mut jl_value_t,
    pub backedges: *mut jl_array_t,
    pub cache: *mut _jl_code_instance_t,
    pub inInference: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _jl_method_instance_t__bindgen_ty_1 {
    pub value: *mut jl_value_t,
    pub module: *mut _jl_module_t,
    pub method: *mut jl_method_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__jl_method_instance_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_jl_method_instance_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_method_instance_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_method_instance_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_jl_method_instance_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t__bindgen_ty_1>())).value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t__bindgen_ty_1>())).module as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t__bindgen_ty_1),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t__bindgen_ty_1>())).method as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t__bindgen_ty_1),
            "::",
            stringify!(method)
        )
    );
}
#[test]
fn bindgen_test_layout__jl_method_instance_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_method_instance_t>(),
        56usize,
        concat!("Size of: ", stringify!(_jl_method_instance_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_method_instance_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_method_instance_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).def as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).specTypes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(specTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t>())).sparam_vals as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(sparam_vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t>())).uninferred as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(uninferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).backedges as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(backedges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).cache as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t>())).inInference as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(inInference)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_code_instance_t {
    pub def: *mut jl_method_instance_t,
    pub next: *mut _jl_code_instance_t,
    pub min_world: usize,
    pub max_world: usize,
    pub rettype: *mut jl_value_t,
    pub rettype_const: *mut jl_value_t,
    pub inferred: *mut jl_value_t,
    pub invoke: jl_callptr_t,
    pub specptr: jl_generic_specptr_t,
    pub functionObjectsDecls: jl_llvm_functions_t,
}
#[test]
fn bindgen_test_layout__jl_code_instance_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_code_instance_t>(),
        88usize,
        concat!("Size of: ", stringify!(_jl_code_instance_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_code_instance_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_code_instance_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_instance_t>())).def as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_instance_t>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_instance_t>())).min_world as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(min_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_instance_t>())).max_world as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(max_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_instance_t>())).rettype as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(rettype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_code_instance_t>())).rettype_const as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(rettype_const)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_instance_t>())).inferred as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(inferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_instance_t>())).invoke as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(invoke)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_instance_t>())).specptr as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(specptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_code_instance_t>())).functionObjectsDecls as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_instance_t),
            "::",
            stringify!(functionObjectsDecls)
        )
    );
}
pub type jl_code_instance_t = _jl_code_instance_t;
pub type jl_function_t = jl_value_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_tvar_t {
    pub name: *mut jl_sym_t,
    pub lb: *mut jl_value_t,
    pub ub: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_tvar_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_tvar_t>(),
        24usize,
        concat!("Size of: ", stringify!(jl_tvar_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_tvar_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_tvar_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_tvar_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_tvar_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_tvar_t>())).lb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_tvar_t),
            "::",
            stringify!(lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_tvar_t>())).ub as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_tvar_t),
            "::",
            stringify!(ub)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_unionall_t {
    pub var: *mut jl_tvar_t,
    pub body: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_unionall_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_unionall_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_unionall_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_unionall_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_unionall_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_unionall_t>())).var as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_unionall_t),
            "::",
            stringify!(var)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_unionall_t>())).body as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_unionall_t),
            "::",
            stringify!(body)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_typename_t {
    pub name: *mut jl_sym_t,
    pub module: *mut _jl_module_t,
    pub names: *mut jl_svec_t,
    pub wrapper: *mut jl_value_t,
    pub cache: *mut jl_svec_t,
    pub linearcache: *mut jl_svec_t,
    pub hash: isize,
    pub mt: *mut _jl_methtable_t,
}
#[test]
fn bindgen_test_layout_jl_typename_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_typename_t>(),
        64usize,
        concat!("Size of: ", stringify!(jl_typename_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_typename_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_typename_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).module as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).names as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).wrapper as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(wrapper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).cache as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).linearcache as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(linearcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).hash as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).mt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(mt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_uniontype_t {
    pub a: *mut jl_value_t,
    pub b: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_uniontype_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_uniontype_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_uniontype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_uniontype_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_uniontype_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uniontype_t>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uniontype_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uniontype_t>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uniontype_t),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_fielddesc8_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub offset: u8,
}
#[test]
fn bindgen_test_layout_jl_fielddesc8_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_fielddesc8_t>(),
        2usize,
        concat!("Size of: ", stringify!(jl_fielddesc8_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_fielddesc8_t>(),
        1usize,
        concat!("Alignment of ", stringify!(jl_fielddesc8_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_fielddesc8_t>())).offset as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_fielddesc8_t),
            "::",
            stringify!(offset)
        )
    );
}
impl jl_fielddesc8_t {
    #[inline]
    pub fn isptr(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isptr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isptr: u8, size: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isptr: u8 = unsafe { ::std::mem::transmute(isptr) };
            isptr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let size: u8 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_fielddesc16_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub offset: u16,
}
#[test]
fn bindgen_test_layout_jl_fielddesc16_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_fielddesc16_t>(),
        4usize,
        concat!("Size of: ", stringify!(jl_fielddesc16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_fielddesc16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(jl_fielddesc16_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_fielddesc16_t>())).offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_fielddesc16_t),
            "::",
            stringify!(offset)
        )
    );
}
impl jl_fielddesc16_t {
    #[inline]
    pub fn isptr(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_isptr(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isptr: u16, size: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isptr: u16 = unsafe { ::std::mem::transmute(isptr) };
            isptr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let size: u16 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_fielddesc32_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_jl_fielddesc32_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_fielddesc32_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_fielddesc32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_fielddesc32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(jl_fielddesc32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_fielddesc32_t>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_fielddesc32_t),
            "::",
            stringify!(offset)
        )
    );
}
impl jl_fielddesc32_t {
    #[inline]
    pub fn isptr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isptr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isptr: u32, size: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isptr: u32 = unsafe { ::std::mem::transmute(isptr) };
            isptr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_datatype_layout_t {
    pub nfields: u32,
    pub npointers: u32,
    pub first_ptr: i32,
    pub alignment: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_jl_datatype_layout_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_datatype_layout_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_datatype_layout_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_datatype_layout_t>(),
        4usize,
        concat!("Alignment of ", stringify!(jl_datatype_layout_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_datatype_layout_t>())).nfields as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_datatype_layout_t),
            "::",
            stringify!(nfields)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_datatype_layout_t>())).npointers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_datatype_layout_t),
            "::",
            stringify!(npointers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_datatype_layout_t>())).first_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_datatype_layout_t),
            "::",
            stringify!(first_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_datatype_layout_t>())).alignment as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_datatype_layout_t),
            "::",
            stringify!(alignment)
        )
    );
}
impl jl_datatype_layout_t {
    #[inline]
    pub fn haspadding(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_haspadding(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fielddesc_type(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_fielddesc_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        haspadding: u16,
        fielddesc_type: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let haspadding: u16 = unsafe { ::std::mem::transmute(haspadding) };
            haspadding as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let fielddesc_type: u16 = unsafe { ::std::mem::transmute(fielddesc_type) };
            fielddesc_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_datatype_t {
    pub name: *mut jl_typename_t,
    pub super_: *mut _jl_datatype_t,
    pub parameters: *mut jl_svec_t,
    pub types: *mut jl_svec_t,
    pub names: *mut jl_svec_t,
    pub instance: *mut jl_value_t,
    pub layout: *const jl_datatype_layout_t,
    pub size: i32,
    pub ninitialized: i32,
    pub uid: u32,
    pub abstract_: u8,
    pub mutabl: u8,
    pub hasfreetypevars: u8,
    pub isconcretetype: u8,
    pub isdispatchtuple: u8,
    pub isbitstype: u8,
    pub zeroinit: u8,
    pub isinlinealloc: u8,
    pub has_concrete_subtype: u8,
    pub struct_decl: *mut ::std::os::raw::c_void,
    pub ditype: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__jl_datatype_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_datatype_t>(),
        96usize,
        concat!("Size of: ", stringify!(_jl_datatype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_datatype_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_datatype_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).super_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(super_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).parameters as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).names as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).instance as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).layout as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).ninitialized as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(ninitialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).uid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).abstract_ as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(abstract_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).mutabl as *const _ as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(mutabl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).hasfreetypevars as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(hasfreetypevars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).isconcretetype as *const _ as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(isconcretetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).isdispatchtuple as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(isdispatchtuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).isbitstype as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(isbitstype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).zeroinit as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(zeroinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).isinlinealloc as *const _ as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(isinlinealloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_datatype_t>())).has_concrete_subtype as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(has_concrete_subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).struct_decl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(struct_decl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).ditype as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(ditype)
        )
    );
}
pub type jl_datatype_t = _jl_datatype_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_weakref_t {
    pub value: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_weakref_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_weakref_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_weakref_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_weakref_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_weakref_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_weakref_t>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_weakref_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_binding_t {
    pub name: *mut jl_sym_t,
    pub value: *mut jl_value_t,
    pub globalref: *mut jl_value_t,
    pub owner: *mut _jl_module_t,
    pub constp: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout_jl_binding_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_binding_t>(),
        40usize,
        concat!("Size of: ", stringify!(jl_binding_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_binding_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_binding_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_binding_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_binding_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_binding_t>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_binding_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_binding_t>())).globalref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_binding_t),
            "::",
            stringify!(globalref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_binding_t>())).owner as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_binding_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_binding_t>())).constp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_binding_t),
            "::",
            stringify!(constp)
        )
    );
}
impl jl_binding_t {
    #[inline]
    pub fn exportp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exportp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn imported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_imported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deprecated(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_deprecated(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        exportp: u8,
        imported: u8,
        deprecated: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let exportp: u8 = unsafe { ::std::mem::transmute(exportp) };
            exportp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let imported: u8 = unsafe { ::std::mem::transmute(imported) };
            imported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let deprecated: u8 = unsafe { ::std::mem::transmute(deprecated) };
            deprecated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_uuid_t {
    pub hi: u64,
    pub lo: u64,
}
#[test]
fn bindgen_test_layout_jl_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_uuid_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uuid_t>())).hi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uuid_t),
            "::",
            stringify!(hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uuid_t>())).lo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uuid_t),
            "::",
            stringify!(lo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_module_t {
    pub name: *mut jl_sym_t,
    pub parent: *mut _jl_module_t,
    pub bindings: htable_t,
    pub usings: arraylist_t,
    pub build_id: u64,
    pub uuid: jl_uuid_t,
    pub primary_world: usize,
    pub counter: u32,
    pub nospecialize: i32,
    pub istopmod: u8,
    pub lock: jl_mutex_t,
}
#[test]
fn bindgen_test_layout__jl_module_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_module_t>(),
        608usize,
        concat!("Size of: ", stringify!(_jl_module_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_module_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_module_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).bindings as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).usings as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(usings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).build_id as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(build_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).uuid as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).primary_world as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(primary_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).counter as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).nospecialize as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(nospecialize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).istopmod as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(istopmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).lock as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(lock)
        )
    );
}
pub type jl_module_t = _jl_module_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_typemap_entry_t {
    pub next: *mut _jl_typemap_entry_t,
    pub sig: *mut jl_tupletype_t,
    pub simplesig: *mut jl_tupletype_t,
    pub guardsigs: *mut jl_svec_t,
    pub min_world: usize,
    pub max_world: usize,
    pub func: _jl_typemap_entry_t__bindgen_ty_1,
    pub isleafsig: i8,
    pub issimplesig: i8,
    pub va: i8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _jl_typemap_entry_t__bindgen_ty_1 {
    pub value: *mut jl_value_t,
    pub linfo: *mut jl_method_instance_t,
    pub method: *mut jl_method_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__jl_typemap_entry_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_jl_typemap_entry_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_typemap_entry_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_typemap_entry_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_jl_typemap_entry_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_typemap_entry_t__bindgen_ty_1>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_typemap_entry_t__bindgen_ty_1>())).linfo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t__bindgen_ty_1),
            "::",
            stringify!(linfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_typemap_entry_t__bindgen_ty_1>())).method as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t__bindgen_ty_1),
            "::",
            stringify!(method)
        )
    );
}
#[test]
fn bindgen_test_layout__jl_typemap_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_typemap_entry_t>(),
        64usize,
        concat!("Size of: ", stringify!(_jl_typemap_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_typemap_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_typemap_entry_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).sig as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).simplesig as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(simplesig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).guardsigs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(guardsigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).min_world as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(min_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).max_world as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(max_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).isleafsig as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(isleafsig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).issimplesig as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(issimplesig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).va as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(va)
        )
    );
}
pub type jl_typemap_entry_t = _jl_typemap_entry_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_ordereddict_t {
    pub indices: *mut jl_array_t,
    pub values: *mut jl_array_t,
}
#[test]
fn bindgen_test_layout_jl_ordereddict_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_ordereddict_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_ordereddict_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_ordereddict_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_ordereddict_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_ordereddict_t>())).indices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_ordereddict_t),
            "::",
            stringify!(indices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_ordereddict_t>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_ordereddict_t),
            "::",
            stringify!(values)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_typemap_level_t {
    pub arg1: jl_ordereddict_t,
    pub targ: jl_ordereddict_t,
    pub linear: *mut jl_typemap_entry_t,
    pub any: *mut jl_typemap_t,
    pub key: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout__jl_typemap_level_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_typemap_level_t>(),
        56usize,
        concat!("Size of: ", stringify!(_jl_typemap_level_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_typemap_level_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_typemap_level_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).arg1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).targ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(targ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).linear as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).any as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(any)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).key as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(key)
        )
    );
}
pub type jl_typemap_level_t = _jl_typemap_level_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_methtable_t {
    pub name: *mut jl_sym_t,
    pub defs: *mut jl_typemap_t,
    pub cache: *mut jl_typemap_t,
    pub max_args: isize,
    pub kwsorter: *mut jl_value_t,
    pub module: *mut jl_module_t,
    pub backedges: *mut jl_array_t,
    pub writelock: jl_mutex_t,
    pub offs: u8,
    pub frozen: u8,
}
#[test]
fn bindgen_test_layout__jl_methtable_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_methtable_t>(),
        80usize,
        concat!("Size of: ", stringify!(_jl_methtable_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_methtable_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_methtable_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).defs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(defs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).cache as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).max_args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(max_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).kwsorter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(kwsorter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).module as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).backedges as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(backedges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).writelock as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(writelock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).offs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(offs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).frozen as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(frozen)
        )
    );
}
pub type jl_methtable_t = _jl_methtable_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_expr_t {
    pub head: *mut jl_sym_t,
    pub args: *mut jl_array_t,
}
#[test]
fn bindgen_test_layout_jl_expr_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_expr_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_expr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_expr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_expr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_expr_t>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_expr_t),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_expr_t>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_expr_t),
            "::",
            stringify!(args)
        )
    );
}
extern "C" {
    pub static mut jl_typeofbottom_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_datatype_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_uniontype_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_unionall_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_tvar_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_any_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_type_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_typetype_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_typename_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_type_typename: *mut jl_typename_t;
}
extern "C" {
    pub static mut jl_symbol_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_ssavalue_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_abstractslot_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_slotnumber_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_typedslot_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_simplevector_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_tuple_typename: *mut jl_typename_t;
}
extern "C" {
    pub static mut jl_vecelement_typename: *mut jl_typename_t;
}
extern "C" {
    pub static mut jl_anytuple_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_emptytuple_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_anytuple_type_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_vararg_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_vararg_typename: *mut jl_typename_t;
}
extern "C" {
    pub static mut jl_function_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_builtin_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_bottom_type: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_method_instance_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_code_instance_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_code_info_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_method_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_module_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_abstractarray_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_densearray_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_array_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_array_typename: *mut jl_typename_t;
}
extern "C" {
    pub static mut jl_weakref_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_abstractstring_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_string_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_errorexception_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_argumenterror_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_loaderror_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_initerror_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_typeerror_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_methoderror_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_undefvarerror_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_lineinfonode_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_stackovf_exception: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_memory_exception: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_readonlymemory_exception: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_diverror_exception: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_undefref_exception: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_interrupt_exception: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_boundserror_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_an_empty_vec_any: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_an_empty_string: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_bool_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_char_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_int8_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_uint8_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_int16_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_uint16_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_int32_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_uint32_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_int64_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_uint64_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_float16_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_float32_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_float64_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_floatingpoint_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_number_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_void_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_signed_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_voidpointer_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_pointer_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_addrspace_pointer_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_ref_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_pointer_typename: *mut jl_typename_t;
}
extern "C" {
    pub static mut jl_addrspace_pointer_typename: *mut jl_typename_t;
}
extern "C" {
    pub static mut jl_namedtuple_typename: *mut jl_typename_t;
}
extern "C" {
    pub static mut jl_namedtuple_type: *mut jl_unionall_t;
}
extern "C" {
    pub static mut jl_task_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_array_uint8_type: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_array_any_type: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_array_symbol_type: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_array_int32_type: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_expr_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_globalref_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_linenumbernode_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_gotonode_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_phinode_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_pinode_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_phicnode_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_upsilonnode_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_quotenode_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_newvarnode_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_intrinsic_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_methtable_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_typemap_level_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_typemap_entry_type: *mut jl_datatype_t;
}
extern "C" {
    pub static mut jl_emptysvec: *mut jl_svec_t;
}
extern "C" {
    pub static mut jl_emptytuple: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_true: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_false: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_nothing: *mut jl_value_t;
}
extern "C" {
    pub static mut jl_incomplete_sym: *mut jl_sym_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_gcframe_t {
    pub nroots: usize,
    pub prev: *mut _jl_gcframe_t,
}
#[test]
fn bindgen_test_layout__jl_gcframe_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_gcframe_t>(),
        16usize,
        concat!("Size of: ", stringify!(_jl_gcframe_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_gcframe_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_gcframe_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_gcframe_t>())).nroots as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_gcframe_t),
            "::",
            stringify!(nroots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_gcframe_t>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_gcframe_t),
            "::",
            stringify!(prev)
        )
    );
}
pub type jl_gcframe_t = _jl_gcframe_t;
extern "C" {
    pub fn jl_gc_enable(on: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_gc_is_enabled() -> ::std::os::raw::c_int;
}
pub const jl_gc_collection_t_JL_GC_AUTO: jl_gc_collection_t = 0;
pub const jl_gc_collection_t_JL_GC_FULL: jl_gc_collection_t = 1;
pub const jl_gc_collection_t_JL_GC_INCREMENTAL: jl_gc_collection_t = 2;
pub type jl_gc_collection_t = u32;
extern "C" {
    pub fn jl_gc_collect(arg1: jl_gc_collection_t);
}
extern "C" {
    pub fn jl_gc_add_finalizer(v: *mut jl_value_t, f: *mut jl_function_t);
}
extern "C" {
    pub fn jl_finalize(o: *mut jl_value_t);
}
extern "C" {
    pub fn jl_gc_new_weakref(value: *mut jl_value_t) -> *mut jl_weakref_t;
}
extern "C" {
    pub fn jl_gc_alloc_0w() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_gc_alloc_1w() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_gc_alloc_2w() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_gc_alloc_3w() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_gc_allocobj(sz: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_malloc_stack(
        bufsz: *mut usize,
        owner: *mut _jl_task_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_free_stack(stkbuf: *mut ::std::os::raw::c_void, bufsz: usize);
}
extern "C" {
    pub fn jl_gc_use(a: *mut jl_value_t);
}
extern "C" {
    pub fn jl_clear_malloc_data();
}
extern "C" {
    pub fn jl_gc_queue_root(root: *mut jl_value_t);
}
extern "C" {
    pub fn jl_gc_queue_multiroot(root: *mut jl_value_t, stored: *mut jl_value_t);
}
extern "C" {
    pub fn jl_gc_managed_malloc(sz: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_gc_managed_realloc(
        d: *mut ::std::os::raw::c_void,
        sz: usize,
        oldsz: usize,
        isaligned: ::std::os::raw::c_int,
        owner: *mut jl_value_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_array_typetagdata(a: *mut jl_array_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_compute_fieldtypes(st: *mut jl_datatype_t) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_subtype(a: *mut jl_value_t, b: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_egal(a: *mut jl_value_t, b: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_object_id(v: *mut jl_value_t) -> usize;
}
extern "C" {
    pub fn jl_has_free_typevars(v: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_has_typevar(t: *mut jl_value_t, v: *mut jl_tvar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_has_typevar_from_unionall(
        t: *mut jl_value_t,
        ua: *mut jl_unionall_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_subtype_env_size(t: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_subtype_env(
        x: *mut jl_value_t,
        y: *mut jl_value_t,
        env: *mut *mut jl_value_t,
        envsz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_isa(a: *mut jl_value_t, t: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_types_equal(a: *mut jl_value_t, b: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_is_not_broken_subtype(
        a: *mut jl_value_t,
        b: *mut jl_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_type_union(ts: *mut *mut jl_value_t, n: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_type_intersection(a: *mut jl_value_t, b: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_has_empty_intersection(
        x: *mut jl_value_t,
        y: *mut jl_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_type_unionall(v: *mut jl_tvar_t, body: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_typename_str(v: *mut jl_value_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_typeof_str(v: *mut jl_value_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_type_morespecific(a: *mut jl_value_t, b: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_unwrap_unionall(v: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_rewrap_unionall(t: *mut jl_value_t, u: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_typename_in(
        name: *mut jl_sym_t,
        inmodule: *mut jl_module_t,
    ) -> *mut jl_typename_t;
}
extern "C" {
    pub fn jl_new_typevar(
        name: *mut jl_sym_t,
        lb: *mut jl_value_t,
        ub: *mut jl_value_t,
    ) -> *mut jl_tvar_t;
}
extern "C" {
    pub fn jl_instantiate_unionall(u: *mut jl_unionall_t, p: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_apply_type(
        tc: *mut jl_value_t,
        params: *mut *mut jl_value_t,
        n: usize,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_apply_type1(tc: *mut jl_value_t, p1: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_apply_type2(
        tc: *mut jl_value_t,
        p1: *mut jl_value_t,
        p2: *mut jl_value_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_apply_tuple_type(params: *mut jl_svec_t) -> *mut jl_tupletype_t;
}
extern "C" {
    pub fn jl_apply_tuple_type_v(p: *mut *mut jl_value_t, np: usize) -> *mut jl_tupletype_t;
}
extern "C" {
    pub fn jl_new_datatype(
        name: *mut jl_sym_t,
        module: *mut jl_module_t,
        super_: *mut jl_datatype_t,
        parameters: *mut jl_svec_t,
        fnames: *mut jl_svec_t,
        ftypes: *mut jl_svec_t,
        abstract_: ::std::os::raw::c_int,
        mutabl: ::std::os::raw::c_int,
        ninitialized: ::std::os::raw::c_int,
    ) -> *mut jl_datatype_t;
}
extern "C" {
    pub fn jl_new_primitivetype(
        name: *mut jl_value_t,
        module: *mut jl_module_t,
        super_: *mut jl_datatype_t,
        parameters: *mut jl_svec_t,
        nbits: usize,
    ) -> *mut jl_datatype_t;
}
extern "C" {
    pub fn jl_new_abstracttype(
        name: *mut jl_value_t,
        module: *mut jl_module_t,
        super_: *mut jl_datatype_t,
        parameters: *mut jl_svec_t,
    ) -> *mut jl_datatype_t;
}
extern "C" {
    pub fn jl_new_bits(bt: *mut jl_value_t, data: *mut ::std::os::raw::c_void) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_struct(type_: *mut jl_datatype_t, ...) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_structv(
        type_: *mut jl_datatype_t,
        args: *mut *mut jl_value_t,
        na: u32,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_structt(type_: *mut jl_datatype_t, tup: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_struct_uninit(type_: *mut jl_datatype_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_method_instance_uninit() -> *mut jl_method_instance_t;
}
extern "C" {
    pub fn jl_svec(n: usize, ...) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_svec1(a: *mut ::std::os::raw::c_void) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_svec2(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_alloc_svec(n: usize) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_alloc_svec_uninit(n: usize) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_svec_copy(a: *mut jl_svec_t) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_svec_fill(n: usize, x: *mut jl_value_t) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_tupletype_fill(n: usize, v: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_symbol(str: *const ::std::os::raw::c_char) -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_symbol_lookup(str: *const ::std::os::raw::c_char) -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_symbol_n(str: *const ::std::os::raw::c_char, len: usize) -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_gensym() -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_tagged_gensym(str: *const ::std::os::raw::c_char, len: i32) -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_get_root_symbol() -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_generic_function_def(
        name: *mut jl_sym_t,
        module: *mut jl_module_t,
        bp: *mut *mut jl_value_t,
        bp_owner: *mut jl_value_t,
        bnd: *mut jl_binding_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_method_def(argdata: *mut jl_svec_t, f: *mut jl_code_info_t, module: *mut jl_module_t);
}
extern "C" {
    pub fn jl_code_for_staged(linfo: *mut jl_method_instance_t) -> *mut jl_code_info_t;
}
extern "C" {
    pub fn jl_copy_code_info(src: *mut jl_code_info_t) -> *mut jl_code_info_t;
}
extern "C" {
    pub fn jl_get_world_counter() -> usize;
}
extern "C" {
    pub fn jl_get_kwsorter(ty: *mut jl_value_t) -> *mut jl_function_t;
}
extern "C" {
    pub fn jl_box_bool(x: i8) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_int8(x: i8) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_uint8(x: u8) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_int16(x: i16) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_uint16(x: u16) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_int32(x: i32) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_uint32(x: u32) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_char(x: u32) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_int64(x: i64) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_uint64(x: u64) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_float32(x: f32) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_float64(x: f64) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_voidpointer(x: *mut ::std::os::raw::c_void) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_ssavalue(x: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_slotnumber(x: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_unbox_bool(v: *mut jl_value_t) -> i8;
}
extern "C" {
    pub fn jl_unbox_int8(v: *mut jl_value_t) -> i8;
}
extern "C" {
    pub fn jl_unbox_uint8(v: *mut jl_value_t) -> u8;
}
extern "C" {
    pub fn jl_unbox_int16(v: *mut jl_value_t) -> i16;
}
extern "C" {
    pub fn jl_unbox_uint16(v: *mut jl_value_t) -> u16;
}
extern "C" {
    pub fn jl_unbox_int32(v: *mut jl_value_t) -> i32;
}
extern "C" {
    pub fn jl_unbox_uint32(v: *mut jl_value_t) -> u32;
}
extern "C" {
    pub fn jl_unbox_int64(v: *mut jl_value_t) -> i64;
}
extern "C" {
    pub fn jl_unbox_uint64(v: *mut jl_value_t) -> u64;
}
extern "C" {
    pub fn jl_unbox_float32(v: *mut jl_value_t) -> f32;
}
extern "C" {
    pub fn jl_unbox_float64(v: *mut jl_value_t) -> f64;
}
extern "C" {
    pub fn jl_unbox_voidpointer(v: *mut jl_value_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_get_size(val: *mut jl_value_t, pnt: *mut usize) -> ::std::os::raw::c_int;
}
pub const jl_vararg_kind_t_JL_VARARG_NONE: jl_vararg_kind_t = 0;
pub const jl_vararg_kind_t_JL_VARARG_INT: jl_vararg_kind_t = 1;
pub const jl_vararg_kind_t_JL_VARARG_BOUND: jl_vararg_kind_t = 2;
pub const jl_vararg_kind_t_JL_VARARG_UNBOUND: jl_vararg_kind_t = 3;
pub type jl_vararg_kind_t = u32;
extern "C" {
    pub fn jl_field_index(
        t: *mut jl_datatype_t,
        fld: *mut jl_sym_t,
        err: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_get_nth_field(v: *mut jl_value_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_get_nth_field_noalloc(v: *mut jl_value_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_get_nth_field_checked(v: *mut jl_value_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_set_nth_field(v: *mut jl_value_t, i: usize, rhs: *mut jl_value_t);
}
extern "C" {
    pub fn jl_field_isdefined(v: *mut jl_value_t, i: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_get_field(o: *mut jl_value_t, fld: *const ::std::os::raw::c_char) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_value_ptr(a: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_islayout_inline(
        eltype: *mut jl_value_t,
        fsz: *mut usize,
        al: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_new_array(atype: *mut jl_value_t, dims: *mut jl_value_t) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_reshape_array(
        atype: *mut jl_value_t,
        data: *mut jl_array_t,
        dims: *mut jl_value_t,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_ptr_to_array_1d(
        atype: *mut jl_value_t,
        data: *mut ::std::os::raw::c_void,
        nel: usize,
        own_buffer: ::std::os::raw::c_int,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_ptr_to_array(
        atype: *mut jl_value_t,
        data: *mut ::std::os::raw::c_void,
        dims: *mut jl_value_t,
        own_buffer: ::std::os::raw::c_int,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_alloc_array_1d(atype: *mut jl_value_t, nr: usize) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_alloc_array_2d(atype: *mut jl_value_t, nr: usize, nc: usize) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_alloc_array_3d(
        atype: *mut jl_value_t,
        nr: usize,
        nc: usize,
        z: usize,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_pchar_to_array(str: *const ::std::os::raw::c_char, len: usize) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_pchar_to_string(str: *const ::std::os::raw::c_char, len: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_cstr_to_string(str: *const ::std::os::raw::c_char) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_alloc_string(len: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_array_to_string(a: *mut jl_array_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_alloc_vec_any(n: usize) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_arrayref(a: *mut jl_array_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_ptrarrayref(a: *mut jl_array_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_arrayset(a: *mut jl_array_t, v: *mut jl_value_t, i: usize);
}
extern "C" {
    pub fn jl_arrayunset(a: *mut jl_array_t, i: usize);
}
extern "C" {
    pub fn jl_array_isassigned(a: *mut jl_array_t, i: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_array_grow_end(a: *mut jl_array_t, inc: usize);
}
extern "C" {
    pub fn jl_array_del_end(a: *mut jl_array_t, dec: usize);
}
extern "C" {
    pub fn jl_array_grow_beg(a: *mut jl_array_t, inc: usize);
}
extern "C" {
    pub fn jl_array_del_beg(a: *mut jl_array_t, dec: usize);
}
extern "C" {
    pub fn jl_array_sizehint(a: *mut jl_array_t, sz: usize);
}
extern "C" {
    pub fn jl_array_ptr_1d_push(a: *mut jl_array_t, item: *mut jl_value_t);
}
extern "C" {
    pub fn jl_array_ptr_1d_append(a: *mut jl_array_t, a2: *mut jl_array_t);
}
extern "C" {
    pub fn jl_apply_array_type(type_: *mut jl_value_t, dim: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_array_ptr(a: *mut jl_array_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_array_eltype(a: *mut jl_value_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_array_rank(a: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_array_size(a: *mut jl_value_t, d: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn jl_string_ptr(s: *mut jl_value_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut jl_main_module: *mut jl_module_t;
}
extern "C" {
    pub static mut jl_core_module: *mut jl_module_t;
}
extern "C" {
    pub static mut jl_base_module: *mut jl_module_t;
}
extern "C" {
    pub static mut jl_top_module: *mut jl_module_t;
}
extern "C" {
    pub fn jl_new_module(name: *mut jl_sym_t) -> *mut jl_module_t;
}
extern "C" {
    pub fn jl_set_module_nospecialize(self_: *mut jl_module_t, on: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_get_binding(m: *mut jl_module_t, var: *mut jl_sym_t) -> *mut jl_binding_t;
}
extern "C" {
    pub fn jl_get_binding_or_error(m: *mut jl_module_t, var: *mut jl_sym_t) -> *mut jl_binding_t;
}
extern "C" {
    pub fn jl_module_globalref(m: *mut jl_module_t, var: *mut jl_sym_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_get_binding_wr(
        m: *mut jl_module_t,
        var: *mut jl_sym_t,
        error: ::std::os::raw::c_int,
    ) -> *mut jl_binding_t;
}
extern "C" {
    pub fn jl_get_binding_for_method_def(
        m: *mut jl_module_t,
        var: *mut jl_sym_t,
    ) -> *mut jl_binding_t;
}
extern "C" {
    pub fn jl_boundp(m: *mut jl_module_t, var: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_defines_or_exports_p(
        m: *mut jl_module_t,
        var: *mut jl_sym_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_binding_resolved_p(m: *mut jl_module_t, var: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_is_const(m: *mut jl_module_t, var: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_get_global(m: *mut jl_module_t, var: *mut jl_sym_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_set_global(m: *mut jl_module_t, var: *mut jl_sym_t, val: *mut jl_value_t);
}
extern "C" {
    pub fn jl_set_const(m: *mut jl_module_t, var: *mut jl_sym_t, val: *mut jl_value_t);
}
extern "C" {
    pub fn jl_checked_assignment(b: *mut jl_binding_t, rhs: *mut jl_value_t);
}
extern "C" {
    pub fn jl_declare_constant(b: *mut jl_binding_t);
}
extern "C" {
    pub fn jl_module_using(to: *mut jl_module_t, from: *mut jl_module_t);
}
extern "C" {
    pub fn jl_module_use(to: *mut jl_module_t, from: *mut jl_module_t, s: *mut jl_sym_t);
}
extern "C" {
    pub fn jl_module_import(to: *mut jl_module_t, from: *mut jl_module_t, s: *mut jl_sym_t);
}
extern "C" {
    pub fn jl_module_export(from: *mut jl_module_t, s: *mut jl_sym_t);
}
extern "C" {
    pub fn jl_is_imported(m: *mut jl_module_t, s: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_module_exports_p(m: *mut jl_module_t, var: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_add_standard_imports(m: *mut jl_module_t);
}
extern "C" {
    pub fn jl_is_submodule(
        child: *mut jl_module_t,
        parent: *mut jl_module_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_eqtable_put(
        h: *mut jl_array_t,
        key: *mut jl_value_t,
        val: *mut jl_value_t,
        inserted: *mut ::std::os::raw::c_int,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_eqtable_get(
        h: *mut jl_array_t,
        key: *mut jl_value_t,
        deflt: *mut jl_value_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_set_errno(e: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_stat(
        path: *const ::std::os::raw::c_char,
        statbuf: *mut ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn jl_cpu_threads() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_getpagesize() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jl_getallocationgranularity() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jl_is_debugbuild() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_get_UNAME() -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_get_ARCH() -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_environ(i: ::std::os::raw::c_int) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_vexceptionf(
        exception_type: *mut jl_datatype_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_error(str: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_errorf(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn jl_exceptionf(ty: *mut jl_datatype_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn jl_too_few_args(fname: *const ::std::os::raw::c_char, min: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_too_many_args(fname: *const ::std::os::raw::c_char, max: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_type_error(
        fname: *const ::std::os::raw::c_char,
        expected: *mut jl_value_t,
        got: *mut jl_value_t,
    );
}
extern "C" {
    pub fn jl_type_error_rt(
        fname: *const ::std::os::raw::c_char,
        context: *const ::std::os::raw::c_char,
        ty: *mut jl_value_t,
        got: *mut jl_value_t,
    );
}
extern "C" {
    pub fn jl_undefined_var_error(var: *mut jl_sym_t);
}
extern "C" {
    pub fn jl_bounds_error(v: *mut jl_value_t, t: *mut jl_value_t);
}
extern "C" {
    pub fn jl_bounds_error_v(v: *mut jl_value_t, idxs: *mut *mut jl_value_t, nidxs: usize);
}
extern "C" {
    pub fn jl_bounds_error_int(v: *mut jl_value_t, i: usize);
}
extern "C" {
    pub fn jl_bounds_error_tuple_int(v: *mut *mut jl_value_t, nv: usize, i: usize);
}
extern "C" {
    pub fn jl_bounds_error_unboxed_int(
        v: *mut ::std::os::raw::c_void,
        vt: *mut jl_value_t,
        i: usize,
    );
}
extern "C" {
    pub fn jl_bounds_error_ints(v: *mut jl_value_t, idxs: *mut usize, nidxs: usize);
}
extern "C" {
    pub fn jl_eof_error();
}
extern "C" {
    pub fn jl_current_exception() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_exception_occurred() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_exception_clear();
}
pub const JL_IMAGE_SEARCH_JL_IMAGE_CWD: JL_IMAGE_SEARCH = 0;
pub const JL_IMAGE_SEARCH_JL_IMAGE_JULIA_HOME: JL_IMAGE_SEARCH = 1;
pub type JL_IMAGE_SEARCH = u32;
extern "C" {
    pub fn julia_init__threading(rel: JL_IMAGE_SEARCH);
}
extern "C" {
    pub fn jl_init__threading();
}
extern "C" {
    pub fn jl_init_with_image__threading(
        julia_bindir: *const ::std::os::raw::c_char,
        image_relative_path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn jl_get_default_sysimg_path() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_is_initialized() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_atexit_hook(status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_exit(status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_pathname_for_handle(
        handle: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_deserialize_verify_header(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_preload_sysimg_so(fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_set_sysimg_so(handle: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn jl_create_system_image() -> *mut ios_t;
}
extern "C" {
    pub fn jl_save_system_image(fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_restore_system_image(fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_restore_system_image_data(buf: *const ::std::os::raw::c_char, len: usize);
}
extern "C" {
    pub fn jl_save_incremental(
        fname: *const ::std::os::raw::c_char,
        worklist: *mut jl_array_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_restore_incremental(
        fname: *const ::std::os::raw::c_char,
        depmods: *mut jl_array_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_restore_incremental_from_buf(
        buf: *const ::std::os::raw::c_char,
        sz: usize,
        depmods: *mut jl_array_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_parse_all(
        str: *const ::std::os::raw::c_char,
        len: usize,
        filename: *const ::std::os::raw::c_char,
        filename_len: usize,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_parse_input_line(
        str: *const ::std::os::raw::c_char,
        len: usize,
        filename: *const ::std::os::raw::c_char,
        filename_len: usize,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_parse_string(
        str: *const ::std::os::raw::c_char,
        len: usize,
        pos0: ::std::os::raw::c_int,
        greedy: ::std::os::raw::c_int,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_load_file_string(
        text: *const ::std::os::raw::c_char,
        len: usize,
        filename: *mut ::std::os::raw::c_char,
        inmodule: *mut jl_module_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_expand(expr: *mut jl_value_t, inmodule: *mut jl_module_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_expand_with_loc(
        expr: *mut jl_value_t,
        inmodule: *mut jl_module_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_expand_stmt(expr: *mut jl_value_t, inmodule: *mut jl_module_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_expand_stmt_with_loc(
        expr: *mut jl_value_t,
        inmodule: *mut jl_module_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_eval_string(str: *const ::std::os::raw::c_char) -> *mut jl_value_t;
}
pub const JL_RTLD_CONSTANT_JL_RTLD_LOCAL: JL_RTLD_CONSTANT = 1;
pub const JL_RTLD_CONSTANT_JL_RTLD_GLOBAL: JL_RTLD_CONSTANT = 2;
pub const JL_RTLD_CONSTANT_JL_RTLD_LAZY: JL_RTLD_CONSTANT = 4;
pub const JL_RTLD_CONSTANT_JL_RTLD_NOW: JL_RTLD_CONSTANT = 8;
pub const JL_RTLD_CONSTANT_JL_RTLD_NODELETE: JL_RTLD_CONSTANT = 16;
pub const JL_RTLD_CONSTANT_JL_RTLD_NOLOAD: JL_RTLD_CONSTANT = 32;
pub const JL_RTLD_CONSTANT_JL_RTLD_DEEPBIND: JL_RTLD_CONSTANT = 64;
pub const JL_RTLD_CONSTANT_JL_RTLD_FIRST: JL_RTLD_CONSTANT = 128;
pub type JL_RTLD_CONSTANT = u32;
pub type jl_uv_libhandle = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn jl_load_dynamic_library(
        fname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        throw_err: ::std::os::raw::c_int,
    ) -> jl_uv_libhandle;
}
extern "C" {
    pub fn jl_dlopen(
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> jl_uv_libhandle;
}
extern "C" {
    pub fn jl_dlclose(handle: jl_uv_libhandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_dlsym(
        handle: jl_uv_libhandle,
        symbol: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_void,
        throw_err: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_toplevel_eval(m: *mut jl_module_t, v: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_toplevel_eval_in(m: *mut jl_module_t, ex: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_load(
        module: *mut jl_module_t,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_base_relative_to(m: *mut jl_module_t) -> *mut jl_module_t;
}
extern "C" {
    pub fn jl_register_newmeth_tracer(
        callback: ::std::option::Option<unsafe extern "C" fn(tracee: *mut jl_method_t)>,
    );
}
extern "C" {
    pub fn jl_copy_ast(expr: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_compress_ast(m: *mut jl_method_t, code: *mut jl_code_info_t) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_uncompress_ast(
        m: *mut jl_method_t,
        metadata: *mut jl_code_instance_t,
        data: *mut jl_array_t,
    ) -> *mut jl_code_info_t;
}
extern "C" {
    pub fn jl_ast_flag_inferred(data: *mut jl_array_t) -> u8;
}
extern "C" {
    pub fn jl_ast_flag_inlineable(data: *mut jl_array_t) -> u8;
}
extern "C" {
    pub fn jl_ast_flag_pure(data: *mut jl_array_t) -> u8;
}
extern "C" {
    pub fn jl_ast_nslots(data: *mut jl_array_t) -> isize;
}
extern "C" {
    pub fn jl_ast_slotflag(data: *mut jl_array_t, i: usize) -> u8;
}
extern "C" {
    pub fn jl_compress_argnames(syms: *mut jl_array_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_uncompress_argnames(syms: *mut jl_value_t) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_uncompress_argname_n(syms: *mut jl_value_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_is_operator(sym: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_is_unary_operator(sym: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_is_unary_and_binary_operator(
        sym: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_operator_precedence(sym: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_apply_generic(
        F: *mut jl_value_t,
        args: *mut *mut jl_value_t,
        nargs: u32,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_invoke(
        F: *mut jl_value_t,
        args: *mut *mut jl_value_t,
        nargs: u32,
        meth: *mut jl_method_instance_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_invoke_api(linfo: *mut jl_code_instance_t) -> i32;
}
extern "C" {
    pub fn jl_call(
        f: *mut jl_function_t,
        args: *mut *mut jl_value_t,
        nargs: i32,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_call0(f: *mut jl_function_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_call1(f: *mut jl_function_t, a: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_call2(
        f: *mut jl_function_t,
        a: *mut jl_value_t,
        b: *mut jl_value_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_call3(
        f: *mut jl_function_t,
        a: *mut jl_value_t,
        b: *mut jl_value_t,
        c: *mut jl_value_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_yield();
}
extern "C" {
    pub fn jl_install_sigint_handler();
}
extern "C" {
    pub fn jl_sigatomic_begin();
}
extern "C" {
    pub fn jl_sigatomic_end();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_timing_block_t {
    _unused: [u8; 0],
}
pub type jl_timing_block_t = _jl_timing_block_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_excstack_t {
    _unused: [u8; 0],
}
pub type jl_excstack_t = _jl_excstack_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_handler_t {
    pub eh_ctx: sigjmp_buf,
    pub gcstack: *mut jl_gcframe_t,
    pub prev: *mut _jl_handler_t,
    pub gc_state: i8,
    pub locks_len: usize,
    pub defer_signal: sig_atomic_t,
    pub finalizers_inhibited: ::std::os::raw::c_int,
    pub timing_stack: *mut jl_timing_block_t,
    pub world_age: usize,
}
#[test]
fn bindgen_test_layout__jl_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_handler_t>(),
        256usize,
        concat!("Size of: ", stringify!(_jl_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_handler_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).eh_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(eh_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).gcstack as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(gcstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).prev as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).gc_state as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(gc_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).locks_len as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(locks_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).defer_signal as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(defer_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_handler_t>())).finalizers_inhibited as *const _ as usize
        },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(finalizers_inhibited)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).timing_stack as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(timing_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).world_age as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(world_age)
        )
    );
}
pub type jl_handler_t = _jl_handler_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_task_t {
    pub next: *mut jl_value_t,
    pub queue: *mut jl_value_t,
    pub tls: *mut jl_value_t,
    pub state: *mut jl_sym_t,
    pub donenotify: *mut jl_value_t,
    pub result: *mut jl_value_t,
    pub exception: *mut jl_value_t,
    pub backtrace: *mut jl_value_t,
    pub logstate: *mut jl_value_t,
    pub start: *mut jl_function_t,
    pub sticky: u8,
    pub ctx: jl_ucontext_t,
    pub stkbuf: *mut ::std::os::raw::c_void,
    pub bufsz: usize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub eh: *mut jl_handler_t,
    pub gcstack: *mut jl_gcframe_t,
    pub excstack: *mut jl_excstack_t,
    pub world_age: usize,
    pub tid: i16,
    pub prio: i16,
    pub locks: arraylist_t,
    pub timing_stack: *mut jl_timing_block_t,
}
#[test]
fn bindgen_test_layout__jl_task_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_task_t>(),
        616usize,
        concat!("Size of: ", stringify!(_jl_task_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_task_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_task_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).tls as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(tls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).state as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).donenotify as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(donenotify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).result as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).exception as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(exception)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).backtrace as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(backtrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).logstate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(logstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).start as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).sticky as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(sticky)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).ctx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).stkbuf as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(stkbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).bufsz as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(bufsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).eh as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(eh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).gcstack as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(gcstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).excstack as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(excstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).world_age as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(world_age)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).tid as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).prio as *const _ as usize },
        346usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).locks as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(locks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).timing_stack as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(timing_stack)
        )
    );
}
impl _jl_task_t {
    #[inline]
    pub fn copy_stack(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_copy_stack(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn started(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_started(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        copy_stack: ::std::os::raw::c_uint,
        started: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let copy_stack: u32 = unsafe { ::std::mem::transmute(copy_stack) };
            copy_stack as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let started: u32 = unsafe { ::std::mem::transmute(started) };
            started as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type jl_task_t = _jl_task_t;
extern "C" {
    pub fn jl_new_task(
        arg1: *mut jl_function_t,
        arg2: *mut jl_value_t,
        arg3: usize,
    ) -> *mut jl_task_t;
}
extern "C" {
    pub fn jl_switchto(pt: *mut *mut jl_task_t);
}
extern "C" {
    pub fn jl_throw(e: *mut jl_value_t);
}
extern "C" {
    pub fn jl_rethrow();
}
extern "C" {
    pub fn jl_sig_throw();
}
extern "C" {
    pub fn jl_rethrow_other(e: *mut jl_value_t);
}
extern "C" {
    pub fn jl_no_exc_handler(e: *mut jl_value_t);
}
extern "C" {
    pub fn jl_enter_handler(eh: *mut jl_handler_t);
}
extern "C" {
    pub fn jl_eh_restore_state(eh: *mut jl_handler_t);
}
extern "C" {
    pub fn jl_pop_handler(n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_excstack_state() -> usize;
}
extern "C" {
    pub fn jl_restore_excstack(state: usize);
}
extern "C" {
    pub fn jl_process_events() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_global_event_loop() -> *mut uv_loop_t;
}
extern "C" {
    pub fn jl_close_uv(handle: *mut uv_handle_t);
}
extern "C" {
    pub fn jl_take_buffer(s: *mut ios_t) -> *mut jl_array_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_uv_file_t {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub file: uv_os_fd_t,
}
#[test]
fn bindgen_test_layout_jl_uv_file_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_uv_file_t>(),
        24usize,
        concat!("Size of: ", stringify!(jl_uv_file_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_uv_file_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_uv_file_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uv_file_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uv_file_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uv_file_t>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uv_file_t),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uv_file_t>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uv_file_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uv_file_t>())).file as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uv_file_t),
            "::",
            stringify!(file)
        )
    );
}
extern "C" {
    pub fn jl_uv_puts(stream: *mut uv_stream_t, str: *const ::std::os::raw::c_char, n: usize);
}
extern "C" {
    pub fn jl_printf(
        s: *mut uv_stream_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_vprintf(
        s: *mut uv_stream_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_safe_printf(str: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub static mut jl_uv_stdin: *mut uv_stream_t;
}
extern "C" {
    pub static mut jl_uv_stdout: *mut uv_stream_t;
}
extern "C" {
    pub static mut jl_uv_stderr: *mut uv_stream_t;
}
extern "C" {
    pub fn jl_stdout_stream() -> *mut uv_stream_t;
}
extern "C" {
    pub fn jl_stdin_stream() -> *mut uv_stream_t;
}
extern "C" {
    pub fn jl_stderr_stream() -> *mut uv_stream_t;
}
extern "C" {
    pub fn jl_flush_cstdio();
}
extern "C" {
    pub fn jl_stdout_obj() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_stderr_obj() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_static_show(out: *mut uv_stream_t, v: *mut jl_value_t) -> usize;
}
extern "C" {
    pub fn jl_static_show_func_sig(s: *mut uv_stream_t, type_: *mut jl_value_t) -> usize;
}
extern "C" {
    pub fn jlbacktrace();
}
extern "C" {
    pub fn jl_(jl_value: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_options_t {
    pub quiet: i8,
    pub banner: i8,
    pub julia_bindir: *const ::std::os::raw::c_char,
    pub julia_bin: *const ::std::os::raw::c_char,
    pub cmds: *mut *const ::std::os::raw::c_char,
    pub image_file: *const ::std::os::raw::c_char,
    pub cpu_target: *const ::std::os::raw::c_char,
    pub nprocs: i32,
    pub machine_file: *const ::std::os::raw::c_char,
    pub project: *const ::std::os::raw::c_char,
    pub isinteractive: i8,
    pub color: i8,
    pub historyfile: i8,
    pub startupfile: i8,
    pub compile_enabled: i8,
    pub code_coverage: i8,
    pub malloc_log: i8,
    pub opt_level: i8,
    pub debug_level: i8,
    pub check_bounds: i8,
    pub depwarn: i8,
    pub warn_overwrite: i8,
    pub can_inline: i8,
    pub polly: i8,
    pub trace_compile: *const ::std::os::raw::c_char,
    pub fast_math: i8,
    pub worker: i8,
    pub cookie: *const ::std::os::raw::c_char,
    pub handle_signals: i8,
    pub use_sysimage_native_code: i8,
    pub use_compiled_modules: i8,
    pub bindto: *const ::std::os::raw::c_char,
    pub outputbc: *const ::std::os::raw::c_char,
    pub outputunoptbc: *const ::std::os::raw::c_char,
    pub outputjitbc: *const ::std::os::raw::c_char,
    pub outputo: *const ::std::os::raw::c_char,
    pub outputji: *const ::std::os::raw::c_char,
    pub output_code_coverage: *const ::std::os::raw::c_char,
    pub incremental: i8,
    pub image_file_specified: i8,
}
#[test]
fn bindgen_test_layout_jl_options_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_options_t>(),
        184usize,
        concat!("Size of: ", stringify!(jl_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_options_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).quiet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(quiet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).banner as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(banner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).julia_bindir as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(julia_bindir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).julia_bin as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(julia_bin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).cmds as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(cmds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).image_file as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(image_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).cpu_target as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(cpu_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).nprocs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(nprocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).machine_file as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(machine_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).project as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(project)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).isinteractive as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(isinteractive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).color as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).historyfile as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(historyfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).startupfile as *const _ as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(startupfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).compile_enabled as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(compile_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).code_coverage as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(code_coverage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).malloc_log as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(malloc_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).opt_level as *const _ as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(opt_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).debug_level as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(debug_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).check_bounds as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(check_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).depwarn as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(depwarn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).warn_overwrite as *const _ as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(warn_overwrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).can_inline as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(can_inline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).polly as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(polly)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).trace_compile as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(trace_compile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).fast_math as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(fast_math)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).worker as *const _ as usize },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(worker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).cookie as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).handle_signals as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(handle_signals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_options_t>())).use_sysimage_native_code as *const _ as usize
        },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(use_sysimage_native_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_options_t>())).use_compiled_modules as *const _ as usize
        },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(use_compiled_modules)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).bindto as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(bindto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputbc as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputbc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputunoptbc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputunoptbc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputjitbc as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputjitbc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputo as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputji as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputji)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_options_t>())).output_code_coverage as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(output_code_coverage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).incremental as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(incremental)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_options_t>())).image_file_specified as *const _ as usize
        },
        177usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(image_file_specified)
        )
    );
}
extern "C" {
    pub static mut jl_options: jl_options_t;
}
extern "C" {
    pub fn jl_sizeof_jl_options() -> isize;
}
extern "C" {
    pub fn jl_parse_opts(
        argcp: *mut ::std::os::raw::c_int,
        argvp: *mut *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn jl_format_filename(
        output_pattern: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_set_ARGS(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_generating_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_major() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_minor() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_patch() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_is_release() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_git_branch() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_git_commit() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_nullable_float64_t {
    pub hasvalue: u8,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_jl_nullable_float64_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_nullable_float64_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_nullable_float64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_nullable_float64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_nullable_float64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_nullable_float64_t>())).hasvalue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_nullable_float64_t),
            "::",
            stringify!(hasvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_nullable_float64_t>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_nullable_float64_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_nullable_float32_t {
    pub hasvalue: u8,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_jl_nullable_float32_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_nullable_float32_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_nullable_float32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_nullable_float32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(jl_nullable_float32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_nullable_float32_t>())).hasvalue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_nullable_float32_t),
            "::",
            stringify!(hasvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_nullable_float32_t>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_nullable_float32_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_cgparams_t {
    pub cached: ::std::os::raw::c_int,
    pub track_allocations: ::std::os::raw::c_int,
    pub code_coverage: ::std::os::raw::c_int,
    pub static_alloc: ::std::os::raw::c_int,
    pub prefer_specsig: ::std::os::raw::c_int,
    pub gnu_pubnames: ::std::os::raw::c_int,
    pub debug_info_kind: ::std::os::raw::c_int,
    pub module_setup: *mut jl_value_t,
    pub module_activation: *mut jl_value_t,
    pub raise_exception: *mut jl_value_t,
    pub emit_function: *mut jl_value_t,
    pub emitted_function: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_cgparams_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_cgparams_t>(),
        72usize,
        concat!("Size of: ", stringify!(jl_cgparams_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_cgparams_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_cgparams_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).cached as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(cached)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).track_allocations as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(track_allocations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).code_coverage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(code_coverage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).static_alloc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(static_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).prefer_specsig as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(prefer_specsig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).gnu_pubnames as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(gnu_pubnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).debug_info_kind as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(debug_info_kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).module_setup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(module_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).module_activation as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(module_activation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).raise_exception as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(raise_exception)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).emit_function as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(emit_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).emitted_function as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(emitted_function)
        )
    );
}
extern "C" {
    pub static mut jl_default_cgparams: jl_cgparams_t;
}
extern "C" {
    pub static mut jl_default_debug_info_kind: ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mallocarray_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bigval_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_value_t {
    pub _address: u8,
}
